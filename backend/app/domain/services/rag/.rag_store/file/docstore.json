{"docstore/metadata": {"file::0": {"doc_hash": "e1d3431e36df64109d429807136c5b451ba9e2ac7f1f1b80c344de7cef237a50"}, "file::1": {"doc_hash": "834f0ad82ce5f07349a25296b8571dea6e24e12ca780d69759909cfaea34c397"}, "file::2": {"doc_hash": "393b4259608e77cae9aaa94c29a652ff4c23b7da9db69eb232276dcde80a14d8"}, "file::3": {"doc_hash": "c7ac2084901ee73c87a20cfffec0b352a1afefc50f4b37042c8c3c3d3757c4fa"}, "file::4": {"doc_hash": "7f1706f5d2bd207eade89089c8a500750def9fb92a460b36ee1237012a768508"}, "file::5": {"doc_hash": "e3967f1b833875295d2c45e5dae81e3e402d66865a9e2d85cb1d131539d0967e"}, "file::6": {"doc_hash": "f3cc0656425bafb1521a54b16f250af4a7c09cc9e360e940063c4a8b395da13c"}, "file::7": {"doc_hash": "3b2712de93f0cebdbbc5ac3f909a14fb2d6b0b0dc78527e983e01059776ebe54"}, "file::8": {"doc_hash": "16fdfadf8b452732a12d19fb0bf6484781294ee8d6a2b09b9bb66593ca73a15b"}, "a6d954a4-f0f9-407a-bfd8-907db7546739": {"doc_hash": "369843a601c6157f54c0b9208befaabee6fa7ec5b88edf4313e652671c105ffd", "ref_doc_id": "file::0"}, "f4cdc22d-bc9f-47b6-a5a5-12caba675ba0": {"doc_hash": "f4a24a80a097fc91aaa333c57a9a6e958b547eb94e908e8b544903b3cfa0a135", "ref_doc_id": "file::1"}, "68ad1bf2-f992-4402-b515-10a96f2d3bff": {"doc_hash": "f971bf60e9993de94b61a7a4e1267336b9b9be46b1ef41d0417d175ca2b367d5", "ref_doc_id": "file::2"}, "22ddaf0a-a969-424e-81e9-c8f02c38062e": {"doc_hash": "3a34783498f7aa0ab0e37f87ac1b471c1336cdb7172246bf07379980d284d5aa", "ref_doc_id": "file::3"}, "bc10555b-aa32-42cb-90a6-1c955d2f7917": {"doc_hash": "534e1125ec839439b574bcebb48a5c12c198b907d3e302233e72bd9d1cfc57b9", "ref_doc_id": "file::4"}, "7481edf2-7357-4615-bc4c-e606f7419658": {"doc_hash": "415393f09164e6f28b22ba4a7af0fa1de0466d94eb95c5f20cb00b2c25ab250e", "ref_doc_id": "file::5"}, "cc9030ce-9c98-4ac2-9319-9a6c60e06a8c": {"doc_hash": "120bfdd80319e34bb541d7a9838d0226d3d1410b92860e3c46f1c71caecbbae5", "ref_doc_id": "file::6"}, "75bc4330-85ef-4a4d-affa-391c8097d91c": {"doc_hash": "00c3cdfe6d3b2364825049002eab0b0221c69984388f272de3db550491e89829", "ref_doc_id": "file::7"}, "43dadf8b-cbb0-4d21-aa7a-5ab5a499ca58": {"doc_hash": "e39e35a6c161e69dcacfbcf90d9b6ca4771f5bce972d72fe3af073060844a44e", "ref_doc_id": "file::8"}}, "docstore/ref_doc_info": {"file::0": {"node_ids": ["a6d954a4-f0f9-407a-bfd8-907db7546739"], "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}}, "file::1": {"node_ids": ["f4cdc22d-bc9f-47b6-a5a5-12caba675ba0"], "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}}, "file::2": {"node_ids": ["68ad1bf2-f992-4402-b515-10a96f2d3bff"], "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}}, "file::3": {"node_ids": ["22ddaf0a-a969-424e-81e9-c8f02c38062e"], "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}}, "file::4": {"node_ids": ["bc10555b-aa32-42cb-90a6-1c955d2f7917"], "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}}, "file::5": {"node_ids": ["7481edf2-7357-4615-bc4c-e606f7419658"], "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}}, "file::6": {"node_ids": ["cc9030ce-9c98-4ac2-9319-9a6c60e06a8c"], "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}}, "file::7": {"node_ids": ["75bc4330-85ef-4a4d-affa-391c8097d91c"], "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}}, "file::8": {"node_ids": ["43dadf8b-cbb0-4d21-aa7a-5ab5a499ca58"], "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}}}, "docstore/data": {"a6d954a4-f0f9-407a-bfd8-907db7546739": {"__data__": {"id_": "a6d954a4-f0f9-407a-bfd8-907db7546739", "embedding": null, "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::0", "node_type": "4", "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}, "hash": "e1d3431e36df64109d429807136c5b451ba9e2ac7f1f1b80c344de7cef237a50", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The file defines two abstract base classes, BaseFlow and BaseSubFlow, which standardize the structure and lifecycle of flows and their sub-flows in the system. It imports and references core domain models (Agent, Plan, Step, Memory, AgentEvent) and a range of external interfaces (LLM variants, Sandbox, Browser, SearchEngine) to enable rich tooling and interaction. Each subclass must define a unique flow_id and can expose a description via a class attribute. BaseFlow provides an initialization pathway that binds an Agent and validates the flow_id, while BaseSubFlow wires together language models and tooling dependencies that sub-flows will use to execute individual planning steps. The two classes together establish the contract for initiating, running, and describing both top-level flows and their constituent sub-flows.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 830, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f4cdc22d-bc9f-47b6-a5a5-12caba675ba0": {"__data__": {"id_": "f4cdc22d-bc9f-47b6-a5a5-12caba675ba0", "embedding": null, "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::1", "node_type": "4", "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}, "hash": "834f0ad82ce5f07349a25296b8571dea6e24e12ca780d69759909cfaea34c397", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "SubPlannerFlow handles the lifecycle of creating and executing a sub-plan under a parent plan. It wires together a SubPlannerAgent and an ExecutionAgent, along with various external interfaces (LLMs, Sandbox, Browser, optional search and multimodal LLMs) and a PromptManager for dynamic prompt construction. The file defines an AgentStatus enum to model flow states and a SubPlannerFlow class that extends BaseSubFlow, including initialization, run-time orchestration, and utilities for reporting and debugging. It relies on a Memory object to accumulate results and on numerous event types to communicate progress and outcomes. The run method implements a loop that creates a sub-plan, executes steps, summarizes and updates the plan, and finally emits a final report and completion events, while emitting intermediate events to callers.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 838, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "68ad1bf2-f992-4402-b515-10a96f2d3bff": {"__data__": {"id_": "68ad1bf2-f992-4402-b515-10a96f2d3bff", "embedding": null, "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::2", "node_type": "4", "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}, "hash": "393b4259608e77cae9aaa94c29a652ff4c23b7da9db69eb232276dcde80a14d8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "File-level summary This file implements the DefaultFlow class, a sub-flow that orchestrates sub-plan creation, execution, updating, and reporting. It coordinates two agents (SubPlannerAgent and ExecutionAgent) and uses multiple external services (LLMs, Sandbox, Browser, optional tools) to produce and run a sub-plan derived from a parent step. It maintains execution state via an internal memory store and a finite set of statuses (idle, planning, executing, updating, reporting, completed). The run method handles prompt updates, sub-plan generation, step-by-step execution, plan updates, and final reporting, emitting PlanCompletedEvent or ReportEvent as outcomes. Heavy logging and careful error handling are used to ensure traceability and resilience.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 756, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "22ddaf0a-a969-424e-81e9-c8f02c38062e": {"__data__": {"id_": "22ddaf0a-a969-424e-81e9-c8f02c38062e", "embedding": null, "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::3", "node_type": "4", "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}, "hash": "c7ac2084901ee73c87a20cfffec0b352a1afefc50f4b37042c8c3c3d3757c4fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "File-level summary The file implements a multi-step, gap-reflection search flow used to answer global questions by breaking them into sub-questions (gaps), optionally searching and reasoning over a knowledge base, and then composing a final answer. It defines a SearchFlow class that coordinates the workflow: rewriting questions into gaps, selecting scoring modes, searching each gap via an ExecutionAgent, scoring and reflecting on failures, and updating a knowledge base. The flow relies on an LLM wrapper (OpenAILLM), domain models such as Plan, Step, Memory, and various event types, as well as prompts from a prompts module. Execution is orchestrated through an asynchronous run method that yields AgentEvent objects (e.g., MessageEvent, ReportEvent) as the flow progresses. The implementation emphasizes serial (non-concurrent) gap processing, result formatting for the knowledge base, and final synthesis of an answer with an optional need-for-more-information signal.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 976, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bc10555b-aa32-42cb-90a6-1c955d2f7917": {"__data__": {"id_": "bc10555b-aa32-42cb-90a6-1c955d2f7917", "embedding": null, "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::4", "node_type": "4", "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}, "hash": "7f1706f5d2bd207eade89089c8a500750def9fb92a460b36ee1237012a768508", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "CodeFlow orchestrates a sub-plan lifecycle by creating and running a dedicated SubPlannerAgent and an ExecutionAgent to generate, execute, update, and finally report on a subplan. It wires together LLMs, a sandbox, a browser, optional tools, and memory, while managing prompt customization, memory updates, and detailed logging across planning, execution, updating, and reporting stages. The file defines an AgentStatus enum to model the sub-flow state transitions and exposes an asynchronous run method that yields various domain events (PlanCreatedEvent, ToolCalledEvent, PlanUpdatedEvent, PlanCompletedEvent, etc.) to its caller. It heavily relies on external components such as PromptManager, memory objects, and the agents, coordinating their interactions while preserving an execution_result log. The __init__ method initializes the sub-planner and executor, prepares their initial prompts, and handles error logging and propagation if agent creation fails.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 963, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7481edf2-7357-4615-bc4c-e606f7419658": {"__data__": {"id_": "7481edf2-7357-4615-bc4c-e606f7419658", "embedding": null, "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::5", "node_type": "4", "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}, "hash": "e3967f1b833875295d2c45e5dae81e3e402d66865a9e2d85cb1d131539d0967e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "FlowFactory and SubFlowFactory orchestration for dynamic flow creation and management. This module defines two factory classes: FlowFactory for high-level flows and SubFlowFactory for sub-flows, both registering available flow types, constructing instances with dependency injection, and exposing information about registered flows. It relies on a collection of BaseFlow/BaseSubFlow implementations and several external interfaces (LLMs, Sandbox, Browser, SearchEngine, Agent) to instantiate concrete flow objects. It also sets up dedicated logging for sub-flow operations and exposes global factory instances (flow_factory and sub_flow_factory) for application-wide reuse. Additionally, it defines a SubPlannerType enum to assist in redirection logic for sub-flows.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 766, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cc9030ce-9c98-4ac2-9319-9a6c60e06a8c": {"__data__": {"id_": "cc9030ce-9c98-4ac2-9319-9a6c60e06a8c", "embedding": null, "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::6", "node_type": "4", "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}, "hash": "f3cc0656425bafb1521a54b16f250af4a7c09cc9e360e940063c4a8b395da13c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "SimpleChatFlow module The module defines a SimpleChatFlow class that implements a lightweight chat flow by directly querying an LLM and streaming results as events to the agent, without any planning or execution steps. It depends on a variety of domain models and external services (Agent, AgentEvent, MessageEvent, DoneEvent, LLM variants, Sandbox, Browser, and an optional SearchEngine) which are wired at construction. The flow is identified by flow_id \"simple_chat\" and is described as suitable for simple Q&A scenarios. It maintains an internal idle state (_is_idle) and exposes an asynchronous run method that yields events (MessageEvent, DoneEvent) as the conversation progresses. The implementation builds a user-facing prompt, delegates to the LLM, and handles errors by yielding an error message event, with logging throughout for traceability.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 854, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "75bc4330-85ef-4a4d-affa-391c8097d91c": {"__data__": {"id_": "75bc4330-85ef-4a4d-affa-391c8097d91c", "embedding": null, "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::7", "node_type": "4", "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}, "hash": "3b2712de93f0cebdbbc5ac3f909a14fb2d6b0b0dc78527e983e01059776ebe54", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The SuperFlow module defines a high-level orchestration flow that coordinates multiple sub-flows to handle complex tasks described by user messages. It relies on various domain models (Agent, Plan, Step, events), planning and reporting agents, and external tools (Sandbox, Browser, SearchEngine, multiple LLM interfaces). It maintains separate memories for planning and knowledge, uses a sub_flow_factory to instantiate concrete sub-flows by task type, and supports parallel execution groups. It uses a specialized logger and provides a run loop that transitions through planning, executing, updating, and reporting phases, producing a stream of AgentEvent objects for downstream consumers. It also implements helpers for task type deduction, plan visualization, and knowledge updates.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 785, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "43dadf8b-cbb0-4d21-aa7a-5ab5a499ca58": {"__data__": {"id_": "43dadf8b-cbb0-4d21-aa7a-5ab5a499ca58", "embedding": null, "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::8", "node_type": "4", "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}, "hash": "16fdfadf8b452732a12d19fb0bf6484781294ee8d6a2b09b9bb66593ca73a15b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The file defines a PlanActFlow class that orchestrates a two-phase flow: planning and executing user requests. It composes three specialized agents (PlannerAgent, ExecutionAgent, NotifyAgent) and wires them to external services such as LLMs, sandbox, browser, and a search engine. The flow maintains a multi-state machine (idle, planning, executing, updating, reporting, completed) and yields a stream of events (AgentEvent, PlanCompletedEvent, DoneEvent) to callers as the user request is processed. It also logs activity through a dedicated plan_act_logger and uses in-memory sharing between components (notifier uses a separate Memory instance shared with the execution path). The module interacts with memory for planner and execution contexts and provides a helper to display plan details. Overall, it coordinates plan creation, step-by-step execution, plan updates, and final reporting while handling interruptions and progress notifications.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 948, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}}