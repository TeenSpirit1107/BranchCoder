{
  "files": [
    {
      "file": "flows/base.py",
      "description": "The file defines two abstract base classes, BaseFlow and BaseSubFlow, which standardize the structure and lifecycle of flows and their sub-flows in the system. It imports and references core domain models (Agent, Plan, Step, Memory, AgentEvent) and a range of external interfaces (LLM variants, Sandbox, Browser, SearchEngine) to enable rich tooling and interaction. Each subclass must define a unique flow_id and can expose a description via a class attribute. BaseFlow provides an initialization pathway that binds an Agent and validates the flow_id, while BaseSubFlow wires together language models and tooling dependencies that sub-flows will use to execute individual planning steps. The two classes together establish the contract for initiating, running, and describing both top-level flows and their constituent sub-flows."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "description": "SubPlannerFlow handles the lifecycle of creating and executing a sub-plan under a parent plan. It wires together a SubPlannerAgent and an ExecutionAgent, along with various external interfaces (LLMs, Sandbox, Browser, optional search and multimodal LLMs) and a PromptManager for dynamic prompt construction. The file defines an AgentStatus enum to model flow states and a SubPlannerFlow class that extends BaseSubFlow, including initialization, run-time orchestration, and utilities for reporting and debugging. It relies on a Memory object to accumulate results and on numerous event types to communicate progress and outcomes. The run method implements a loop that creates a sub-plan, executes steps, summarizes and updates the plan, and finally emits a final report and completion events, while emitting intermediate events to callers."
    },
    {
      "file": "flows/default_flow.py",
      "description": "File-level summary This file implements the DefaultFlow class, a sub-flow that orchestrates sub-plan creation, execution, updating, and reporting. It coordinates two agents (SubPlannerAgent and ExecutionAgent) and uses multiple external services (LLMs, Sandbox, Browser, optional tools) to produce and run a sub-plan derived from a parent step. It maintains execution state via an internal memory store and a finite set of statuses (idle, planning, executing, updating, reporting, completed). The run method handles prompt updates, sub-plan generation, step-by-step execution, plan updates, and final reporting, emitting PlanCompletedEvent or ReportEvent as outcomes. Heavy logging and careful error handling are used to ensure traceability and resilience."
    },
    {
      "file": "flows/search_flow.py",
      "description": "File-level summary The file implements a multi-step, gap-reflection search flow used to answer global questions by breaking them into sub-questions (gaps), optionally searching and reasoning over a knowledge base, and then composing a final answer. It defines a SearchFlow class that coordinates the workflow: rewriting questions into gaps, selecting scoring modes, searching each gap via an ExecutionAgent, scoring and reflecting on failures, and updating a knowledge base. The flow relies on an LLM wrapper (OpenAILLM), domain models such as Plan, Step, Memory, and various event types, as well as prompts from a prompts module. Execution is orchestrated through an asynchronous run method that yields AgentEvent objects (e.g., MessageEvent, ReportEvent) as the flow progresses. The implementation emphasizes serial (non-concurrent) gap processing, result formatting for the knowledge base, and final synthesis of an answer with an optional need-for-more-information signal."
    },
    {
      "file": "flows/code_flow.py",
      "description": "CodeFlow orchestrates a sub-plan lifecycle by creating and running a dedicated SubPlannerAgent and an ExecutionAgent to generate, execute, update, and finally report on a subplan. It wires together LLMs, a sandbox, a browser, optional tools, and memory, while managing prompt customization, memory updates, and detailed logging across planning, execution, updating, and reporting stages. The file defines an AgentStatus enum to model the sub-flow state transitions and exposes an asynchronous run method that yields various domain events (PlanCreatedEvent, ToolCalledEvent, PlanUpdatedEvent, PlanCompletedEvent, etc.) to its caller. It heavily relies on external components such as PromptManager, memory objects, and the agents, coordinating their interactions while preserving an execution_result log. The __init__ method initializes the sub-planner and executor, prepares their initial prompts, and handles error logging and propagation if agent creation fails."
    },
    {
      "file": "flows/factory.py",
      "description": "FlowFactory and SubFlowFactory orchestration for dynamic flow creation and management. This module defines two factory classes: FlowFactory for high-level flows and SubFlowFactory for sub-flows, both registering available flow types, constructing instances with dependency injection, and exposing information about registered flows. It relies on a collection of BaseFlow/BaseSubFlow implementations and several external interfaces (LLMs, Sandbox, Browser, SearchEngine, Agent) to instantiate concrete flow objects. It also sets up dedicated logging for sub-flow operations and exposes global factory instances (flow_factory and sub_flow_factory) for application-wide reuse. Additionally, it defines a SubPlannerType enum to assist in redirection logic for sub-flows."
    },
    {
      "file": "flows/simple_chat.py",
      "description": "SimpleChatFlow module The module defines a SimpleChatFlow class that implements a lightweight chat flow by directly querying an LLM and streaming results as events to the agent, without any planning or execution steps. It depends on a variety of domain models and external services (Agent, AgentEvent, MessageEvent, DoneEvent, LLM variants, Sandbox, Browser, and an optional SearchEngine) which are wired at construction. The flow is identified by flow_id \"simple_chat\" and is described as suitable for simple Q&A scenarios. It maintains an internal idle state (_is_idle) and exposes an asynchronous run method that yields events (MessageEvent, DoneEvent) as the conversation progresses. The implementation builds a user-facing prompt, delegates to the LLM, and handles errors by yielding an error message event, with logging throughout for traceability."
    },
    {
      "file": "flows/super_flow.py",
      "description": "The SuperFlow module defines a high-level orchestration flow that coordinates multiple sub-flows to handle complex tasks described by user messages. It relies on various domain models (Agent, Plan, Step, events), planning and reporting agents, and external tools (Sandbox, Browser, SearchEngine, multiple LLM interfaces). It maintains separate memories for planning and knowledge, uses a sub_flow_factory to instantiate concrete sub-flows by task type, and supports parallel execution groups. It uses a specialized logger and provides a run loop that transitions through planning, executing, updating, and reporting phases, producing a stream of AgentEvent objects for downstream consumers. It also implements helpers for task type deduction, plan visualization, and knowledge updates."
    },
    {
      "file": "flows/plan_act.py",
      "description": "The file defines a PlanActFlow class that orchestrates a two-phase flow: planning and executing user requests. It composes three specialized agents (PlannerAgent, ExecutionAgent, NotifyAgent) and wires them to external services such as LLMs, sandbox, browser, and a search engine. The flow maintains a multi-state machine (idle, planning, executing, updating, reporting, completed) and yields a stream of events (AgentEvent, PlanCompletedEvent, DoneEvent) to callers as the user request is processed. It also logs activity through a dedicated plan_act_logger and uses in-memory sharing between components (notifier uses a separate Memory instance shared with the execution path). The module interacts with memory for planner and execution contexts and provides a helper to display plan details. Overall, it coordinates plan creation, step-by-step execution, plan updates, and final reporting while handling interruptions and progress notifications."
    }
  ],
  "functions": [
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.__init__",
      "source": "    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes a flow with an Agent, stores the agent, and validates that a unique flow_id has been defined on the subclass; raises ValueError if flow_id is not defined."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract coroutine that takes a message string and is expected to yield AgentEvent objects asynchronously as the flow processes input; to be implemented by concrete flow subclasses."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract method that should return whether the flow is currently idle (not busy); to be implemented by concrete flows."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Class method that returns the unique flow_id for the flow class."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Class method that returns a textual description for the flow, either from a description attribute or a default fallback."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes a sub-flow with various tooling and model interfaces (LLM, Sandbox, Browser, SearchEngine, Audio/Image/Video LLMs, Reason LLM) and an optional task_type; stores these as instance attributes for later use by run implementations."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.run",
      "source": "    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract coroutine that executes a single step of a parent plan, given the parent Plan, parent Step, and parent Memory, along with a task_type; yields AgentEvent objects describing progress, tool usage, and results."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract method that should return whether the sub-flow is currently idle; to be implemented by concrete sub-flow classes."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Class method that returns the unique flow_id for the sub-flow class."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Class method that returns a textual description for the sub-flow, using a description attribute if present or a default."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Constructor that sets up a dedicated logger, initializes memory for execution results, calls the superclass initializer, configures flow status, and creates SubPlannerAgent and ExecutionAgent instances with provided components; includes robust error handling to log and re-raise initialization failures."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Async generator that orchestrates the sub-planning and execution lifecycle for a given parent plan/step; updates system prompts, creates a sub-plan, executes steps, summarizes and updates the sub-plan, produces a final report, and yields various AgentEvent subtypes to consumers until completion."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the flow is currently in the IDLE state, indicating it is not actively processing."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Utility that logs the current plan details (IDs, goals, steps, and statuses) for debugging and traceability."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Constructs the DefaultFlow by initializing a specialized logger, creating an execution_result memory, calling the base constructor, and instantiating a SubPlannerAgent and an ExecutionAgent with the provided LLMs, sandbox, browser, and optional tools; initializes status to IDLE and plan to None; includes error handling to log and raise on failure."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Orchestrates the sub-flow for a given parent plan/step/memory; updates system prompts for the sub-planner and executor, creates a sub-plan from the parent step description, executes the sub-plan step-by-step via the executor, handles tool-related events, summarizes and updates the sub-plan, and finally yields a final ReportEvent or PlanCompletedEvent when finished. It manages status transitions between PLANNING, EXECUTING, UPDATING, REPORTING, and COMPLETED, and interacts with both SubPlannerAgent and ExecutionAgent throughout."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns True if the current internal status is IDLE, otherwise False."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs the details of a plan, including its ID, goal, and all steps with their IDs, descriptions, statuses, results, and errors."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Constructor that initializes the search flow with LLMs, tool integrations, and optional task configurations; it sets up an empty knowledge store, a maximum iteration limit, a processed gaps tracker, and idle status. No return value."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.is_idle",
      "source": "    def is_idle(self):\n        return self.status == \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns True if the flow status is \"idle\"; provides a simple internal state check. No side effects."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.run",
      "source": "    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Main asynchronous generator entry point that handles parameter compatibility, constructs an ExecutionAgent, and orchestrates the end-to-end flow: initialize, choose scoring modes, generate and filter gaps, iteratively search and score gaps, reflect on failures, update knowledge, and finally generate a final answer; yields various AgentEvent messages during progression and sets the final answer on the parent memory/step."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.select_scoring_mode",
      "source": "    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Asynchronously determines which evaluation modes to apply by sending a prompt to the LLM and parsing its JSON output into a list of eval types (fallback to \"basic\" if parsing fails). Returns a list of scoring modes."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_gaps",
      "source": "    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Generates sub-questions (gaps) from the global question by asking the LLM with a time-aware system prompt; parses the response as JSON, formats each query into a gap string, and returns a list of gaps (fallback to [global_question] on error)."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.search_gap",
      "source": "    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Uses the current knowledge base to build a specialized prompt and delegates the actual search to the ExecutionAgent by constructing a Plan and Step. Returns a dict containing the gap and the collected results (or the executed messages) upon completion or failure."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.score_gap",
      "source": "    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Scores whether a gap’s result satisfies the given eval types by calling the LLM with the appropriate prompts; returns a tuple (bool, reason) indicating success and the reasoning text, aggregating results across all eval types."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._get_prompts",
      "source": "    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Internal helper that returns a pair (system_prompt, user_prompt) for a given eval_type (e.g., definitive, freshness, basic, file, etc.) using the prompts module; raises on unknown eval_type."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.analyze_gap",
      "source": "    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Analyses why a gap’s search result failed by asking the LLM with a diagnostic prompt and returning the concise analysis text."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap",
      "source": "    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "Generates new, refined gaps by prompting the LLM to analyze a failed gap and rewrite a more precise search query; returns a list of new gaps (may be empty on failure)."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap_batch",
      "source": "    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Batch-reflects on multiple failed gaps to produce a set of new gaps by summarizing failures and gaps; returns a list of new gaps derived from a combined prompt."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._filter_and_update_gaps",
      "source": "    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Filters out already-processed gaps, updates the internal processed set, and returns the new-unseen gaps to process next. No external side effects besides internal state."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.format_search_result",
      "source": "    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Normalizes a result object (which may be a dict, list, or string) into a readable string; prioritizes known fields (title, summary, content, etc.) and handles error cases gracefully. Used to format results for the knowledge base."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_final_answer",
      "source": "    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Compiles the knowledge base into a final prompt and asks the LLM to produce a JSON object containing the final answer and a need_more flag; returns a tuple (answer, need_more) or a fallback when parsing fails."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.summarize_execution",
      "source": "    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "Async generator that yields a brief execution summary message; available for optional usage."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_report",
      "source": "    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Async generator that yields a final report message; available for optional usage."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the CodeFlow by configuring a specialized sub-planner logger, storing the provided LLMs and tools, creating a dedicated Memory for execution results, invoking the base class initializer, and constructing SubPlannerAgent and ExecutionAgent instances with initial system prompts. It also logs parameter details and raises on failures to instantiate the agents."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronously runs the sub-flow to create and execute a subplan, updating prompts/memory as the flow progresses. It first creates a subplan from the parent plan/step, then iterates through plan creation events, executes steps via the ExecutionAgent, updates the subplan when needed, collects executor outputs, and finally yields a report and plan-completion events; it yields a sequence of AgentEvent instances to the caller."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the current flow status equals IDLE, indicating no active sub-flow process."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs the details of a given Plan, including its ID, goal, and descriptions/status for each step for debugging/auditing purposes."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize the FlowFactory by preparing an internal mapping of flow_id to flow classes and registering default flows via _register_default_flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Register the default flow types (PlanActFlow, SimpleChatFlow, and SuperFlow) and log the registrations; include a delayed import for SuperFlow to avoid circular imports."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Validate that flow_class is a subclass of BaseFlow, obtain its flow_id via get_flow_id, register it in the internal mapping, and log the outcome (warning if overriding an existing id, error if invalid)."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.create_flow",
      "source": "    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Create a flow instance by flow_id using supplied dependencies (agent, llm, audio_llm, image_llm, video_llm, reason_llm, sandbox, browser, optional search_engine); raise if the flow_id is unknown, log success or errors, and return a BaseFlow instance."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return a list of dictionaries describing available flows, each with flow_id, name, and description."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Return whether a given flow_id exists in the registered flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Retrieve the registered flow class for a given flow_id or None if not registered."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize the SubFlowFactory, set up a dedicated logger via setup_sub_planner_flow_logger, and register default sub-flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Register the default sub-flow types (DefaultFlow, SearchFlow, CodeFlow) and log registrations."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Validate that flow_class is a subclass of BaseSubFlow, obtain flow_id via get_flow_id, register it in the internal mapping, and log the outcome (warning if overriding, error if invalid)."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.create_flow",
      "source": "    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Create a sub-flow instance based on the provided llm, task_type, sandbox, browser, and optional engines; apply redirection logic to map some task types to a general/default flow, instantiate the flow_class with appropriate arguments, and log detailed steps and errors."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return a list of dictionaries describing available sub-flows, each with flow_id, name, and description."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows_enum",
      "source": "    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Build and return a dynamic Enum type representing available sub-flows, based on current registrations."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Return whether a given flow_id exists among registered sub-flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Retrieve the registered sub-flow class for a given flow_id or None if not registered."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize the SimpleChatFlow with an Agent, multiple LLM interfaces (llm, audio_llm, image_llm, video_llm, reason_llm), Sandbox, Browser, and an optional SearchEngine; stores references, marks the flow as idle, calls the base constructor, and logs creation."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronously handle a user message by building a prompt, invoking the LLM, yielding a MessageEvent with the response, and finally yielding a DoneEvent; manages idle state and error handling with appropriate event emission."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Return the current idle state of the flow (whether it is ready to process input)."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the SuperFlow with dependencies: agent, llm, sandbox, browser, optional search_engine and LLMs; sets up loggers, memories, creates PlannerAgent and ReportAgent, obtains sub_flow_factory and sub_flow_type enum, creates NotifyAgent, and initializes parallel execution state structures."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._determine_task_type",
      "source": "    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns a task_type string (\"code\",\"search\",\"reasoning\",\"file\") by scanning the description for keywords; defaults to \"search\"."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.execute_step",
      "source": "    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Given a Step, determines task_type (from step.sub_flow_type or description), creates a SubFlow via sub_flow_factory, runs it, and translates sub-flow events into Step-related events; updates step status and results; handles errors and pauses; yields StepStartedEvent, StepFailedEvent, StepCompletedEvent, MessageEvent (simplified), or PauseEvent; logs."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._build_parallel_execution_groups",
      "source": "    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Build self.parallel_sub_flow_groups as deque of groups based on step.sub_plan_step ordering; validates steps, handles errors, groups steps by increasing sub_plan_step numbers; logs."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Main generator loop that processes user messages; handles idle/planning/executing/updating/reporting/completed states; triggers notifier, planner_agent.create_plan, yields events; orchestrates step execution, knowledge updates, and plan updates; updates plan status, builds groups, yields PlanCompletedEvent and DoneEvent."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns True if status is IDLE."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs the plan details (id, goal, steps, statuses)."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_report_to_knowledge",
      "source": "    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "Adds a Message to knowledge memory with role assistant containing the current_report."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_step_to_knowledge",
      "source": "    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "Adds a Message to knowledge memory with role user containing the current_step."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the PlanActFlow with agent, multiple LLMs, sandbox, browser, and optional search engine; sets up internal state, creates PlannerAgent, ExecutionAgent, and NotifyAgent (sharing memory where needed), configures dedicated loggers, and initializes the plan to None and status to IDLE."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronous generator that processes an input message through a state machine (IDLE -> PLANNING -> EXECUTING -> UPDATING -> REPORTING -> COMPLETED); delegates work to notifier, planner, and executor, yielding events from each subcomponent and handling rollbacks if interrupted; upon completion, yields a PlanCompletedEvent and a final DoneEvent."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the current status is IDLE, indicating the flow is ready to accept a new message."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs the details of the given plan (id, goal, and per-step attributes) to aid debugging and traceability."
    }
  ],
  "classes": [
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseFlow",
      "qualname": "<module>.BaseFlow",
      "source": "class BaseFlow(ABC):\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n    \n    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n\n    @abstractmethod\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n    \n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "methods": [
        "<module>.BaseFlow.__init__",
        "<module>.BaseFlow.run",
        "<module>.BaseFlow.is_idle",
        "<module>.BaseFlow.get_flow_id",
        "<module>.BaseFlow.get_description"
      ],
      "description": "An abstract base class that enforces a unique flow_id for each flow, defines the lifecycle contract (run and idle checks), and provides helpers to retrieve the flow identifier and description; interacts with an Agent and is intended to be subclassed by concrete high-level flows."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseSubFlow",
      "qualname": "<module>.BaseSubFlow",
      "source": "class BaseSubFlow(ABC):\n    \"\"\"\n    子规划器流程的基础接口类\n    定义了子规划器流程必须实现的核心方法\n    \"\"\"\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n\n    # 初始化SubFlow可用的基础设施\n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n\n    @abstractmethod\n    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n\n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "methods": [
        "<module>.BaseSubFlow.__init__",
        "<module>.BaseSubFlow.run",
        "<module>.BaseSubFlow.is_idle",
        "<module>.BaseSubFlow.get_flow_id",
        "<module>.BaseSubFlow.get_description"
      ],
      "description": "An abstract base class for sub-planning units that aggregates LLMs and tooling interfaces (sandbox, browser, search, audio/image/video LLMs, reason LLM) and defines the contract for running a single planning step (taking a parent plan/step/memory and task type) and for idle status, along with helpers to obtain flow identifiers and descriptions; interacts with parent planning constructs and external tools."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "An enumeration of the SubPlannerFlow’s lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING) used to drive the orchestration logic."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "SubPlannerFlow",
      "qualname": "<module>.SubPlannerFlow",
      "source": "class SubPlannerFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"general\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.SubPlannerFlow.__init__",
        "<module>.SubPlannerFlow.run",
        "<module>.SubPlannerFlow.is_idle",
        "<module>.SubPlannerFlow._show_plan"
      ],
      "description": "A flow that coordinates sub-plan creation and execution by delegating to SubPlannerAgent and ExecutionAgent, managing prompts/memory, handling events, and emitting final plan results and completion signals."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "An enumeration of the SubPlannerFlow’s lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING) used to drive the orchestration logic."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "DefaultFlow",
      "qualname": "<module>.DefaultFlow",
      "source": "class DefaultFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"default\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.DefaultFlow.__init__",
        "<module>.DefaultFlow.run",
        "<module>.DefaultFlow.is_idle",
        "<module>.DefaultFlow._show_plan"
      ],
      "description": "Class that coordinates sub-plan creation and execution by integrating SubPlannerAgent and ExecutionAgent, managing prompts and memory, and providing an asynchronous run method that yields planning/execution/update events and final reports."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/search_flow.py",
      "name": "SearchFlow",
      "qualname": "<module>.SearchFlow",
      "source": "class SearchFlow(BaseSubFlow):\n    flow_id = \"search\"\n    description = \"多步gap反射搜索流程\"\n\n    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n\n    def is_idle(self):\n        return self.status == \"idle\"\n\n    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n\n    # ========== 以下为各模块实现 ==========\n\n    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n\n    #生成gap\n    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n\n    #由run方法中串行调用，利用executor搜索单个gap\n    # async def search_gap(self, gap: str) -> dict:\n    #     #print(\"search_gap 搜索问题 运行到了\")\n    #     # 1. 构造一个step\n    #     # step = Step(\n    #     #     id=\"search_gap\",\n    #     #     description=f\"请使用搜索工具检索以下内容：{gap}\",\n    #     #     status=ExecutionStatus.PENDING\n    #     # )\n    #     step = Step(\n    #         id=\"search_gap\",\n    #         description=(\n    #             f\"You have access to all available tools, including search engines, web browsers, code execution, and multimedia analysis.\"\n    #             f\"\\nPlease select the most appropriate tool(s) to solve the following sub-question. \"\n    #             f\"Actively call the needed tools, integrate their output, and provide a clear answer.\"\n    #             f\"If you encounter a question that needs reading files(pdf/word/txt) to obtain the answer, you should try to download the file from the internet for more accurate answers.\"\n    #             f\"If you are required to find answers from related essays, articles or books, you should download them and check the file by reading them locally.\"\n    #             f\"In most conditions, searching information about content of an article/book/essay is not a good idea, not much information can be found online, download and read the file if needed.\"\n    #             f\"\\nSub-question: {gap}\"\n    #         ),\n    #         status=ExecutionStatus.PENDING\n    #     )\n    #\n    #     # 2. 构造一个最小Plan\n    #     plan = Plan(\n    #         id=\"search_gap_plan\",\n    #         title=\"Search Gap Task\",\n    #         goal=gap,\n    #         steps=[step]\n    #     )\n    #     all_messages = []\n    #     final_result = None\n    #     final_error = None\n    #\n    #     # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n    #     async for event in self.executor.execute_step(plan, step, gap):\n    #         if hasattr(event, \"message\"):\n    #             all_messages.append(event.message)\n    #         if isinstance(event, StepCompletedEvent):\n    #             # 把最终 result 也放到 messages 最后\n    #             all_messages.append(event.step.result)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #         elif isinstance(event, StepFailedEvent):\n    #             # 错误处理\n    #             all_messages.append(event.step.error)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #\n    #\n    #     # 4. fallback，兜底\n    #     #print(\"如果gap no result found，以下会被打印：\")\n    #     #print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n    #     # return {\"gap\": gap, \"error\": \"No result\"}\n    #     all_messages.append(\"No result\")\n    #     return {\"gap\": gap, \"result\": all_messages}\n\n    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n\n\n    #为gap执行结果打分，打分为boolean值\n    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n\n\n    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n\n\n    #analyze分析本次gap执行错误的原因\n    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n\n    #reflect负责根据失败原因提供新的gap\n    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n\n    #reflect batch负责一整轮gap结束后的反思以及提供新gap，实现一个简单的没有plan的递进\n    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n\n\n    #为避免出现过于相似或者重复的gap，generate后使用filter去重\n    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n\n    #此处规范化result，保证知识库内信息不为空\n    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n\n    #最后一步，生成最终报告\n    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n\n    # ========== 可选 summary/report 接口 ==========\n    # 两个方法视情况使用，目前在代码中并未用到\n\n    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n        # 可以输出 self.knowledge 等\n\n    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "methods": [
        "<module>.SearchFlow.__init__",
        "<module>.SearchFlow.is_idle",
        "<module>.SearchFlow.run",
        "<module>.SearchFlow.select_scoring_mode",
        "<module>.SearchFlow.generate_gaps",
        "<module>.SearchFlow.search_gap",
        "<module>.SearchFlow.score_gap",
        "<module>.SearchFlow._get_prompts",
        "<module>.SearchFlow.analyze_gap",
        "<module>.SearchFlow.reflect_gap",
        "<module>.SearchFlow.reflect_gap_batch",
        "<module>.SearchFlow._filter_and_update_gaps",
        "<module>.SearchFlow.format_search_result",
        "<module>.SearchFlow.generate_final_answer",
        "<module>.SearchFlow.summarize_execution",
        "<module>.SearchFlow.generate_report"
      ],
      "description": "A flow controller that orchestrates a multi-step gap-reflection search process. It interacts with an ExecutionAgent (to perform gap searches), a memory model, Plan/Step domain objects, and an LLM wrapper to rewrite questions, evaluate results, reflect on failures, and synthesize a final answer; its run method is the central orchestrator, emitting events to drive the rest of the system."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "An enumeration representing the lifecycle states of the sub-flow (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING), used to control transitions in the asynchronous run loop."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "CodeFlow",
      "qualname": "<module>.CodeFlow",
      "source": "class CodeFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"code\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.CodeFlow.__init__",
        "<module>.CodeFlow.run",
        "<module>.CodeFlow.is_idle",
        "<module>.CodeFlow._show_plan"
      ],
      "description": "The main orchestrator for the code sub-flow that coordinates SubPlannerAgent and ExecutionAgent, maintains the current plan and status, updates prompts/memory, and yields domain events as the sub-plan progresses through planning, execution, updating, and reporting phases. It exposes helper methods for idle checking and internal plan visualization."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "FlowFactory",
      "qualname": "<module>.FlowFactory",
      "source": "class FlowFactory:\n    \"\"\"Flow工厂类,负责管理和创建不同类型的flow\"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n    \n    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n    \n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.FlowFactory.__init__",
        "<module>.FlowFactory._register_default_flows",
        "<module>.FlowFactory.register_flow",
        "<module>.FlowFactory.create_flow",
        "<module>.FlowFactory.get_available_flows",
        "<module>.FlowFactory.has_flow",
        "<module>.FlowFactory.get_flow_class"
      ],
      "description": "A factory that registers and creates high-level Flow objects, performing dependency injection and error handling, and exposing available flow information to other components."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    CODE = \"code\"\n    REASONING = \"reasoning\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "An enumeration placeholder to represent sub-flow categories used by the SubFlowFactory for redirection and mapping logic."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubFlowFactory",
      "qualname": "<module>.SubFlowFactory",
      "source": "class SubFlowFactory:\n    \"\"\"\n    子流程工厂类\n    负责创建和管理所有子流程实例\n    \"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n    \n    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n\n    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n\n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.SubFlowFactory.__init__",
        "<module>.SubFlowFactory._register_default_flows",
        "<module>.SubFlowFactory.register_flow",
        "<module>.SubFlowFactory.create_flow",
        "<module>.SubFlowFactory.get_available_flows",
        "<module>.SubFlowFactory.get_available_flows_enum",
        "<module>.SubFlowFactory.has_flow",
        "<module>.SubFlowFactory.get_flow_class"
      ],
      "description": "A specialized factory managing registration, creation, and listing of sub-flows; includes a dedicated logger and a redirection mechanism to route certain task types to appropriate flow implementations."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/simple_chat.py",
      "name": "SimpleChatFlow",
      "qualname": "<module>.SimpleChatFlow",
      "source": "class SimpleChatFlow(BaseFlow):\n    \"\"\"简单聊天流程：直接与LLM对话，不进行计划和执行\"\"\"\n    \n    # 定义flow的唯一标识符\n    flow_id = \"simple_chat\"\n    description = \"简单聊天流程：直接与LLM对话，适用于简单的问答场景\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n    \n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n    \n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "methods": [
        "<module>.SimpleChatFlow.__init__",
        "<module>.SimpleChatFlow.run",
        "<module>.SimpleChatFlow.is_idle"
      ],
      "description": "A SimpleChatFlow that directly chats with an LLM without planning or execution steps; manages dependencies (LLMs, sandbox, browser, optional search engine) and streams AgentEvents (MessageEvent and DoneEvent) as the chat progresses."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "FlowStatus",
      "qualname": "<module>.FlowStatus",
      "source": "class FlowStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "Enum of lifecycle states for SuperFlow: IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING, with string values."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "SuperFlow",
      "qualname": "<module>.SuperFlow",
      "source": "class SuperFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"TreeFLow\"\n    description = \"a flow that uses multiple planners to handle complex tasks\"\n\n    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n\n\n    @staticmethod\n    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n\n\n    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n\n\n    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n\n    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n\n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n\n    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n\n    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "methods": [
        "<module>.SuperFlow.__init__",
        "<module>.SuperFlow._determine_task_type",
        "<module>.SuperFlow.execute_step",
        "<module>.SuperFlow._build_parallel_execution_groups",
        "<module>.SuperFlow.run",
        "<module>.SuperFlow.is_idle",
        "<module>.SuperFlow._show_plan",
        "<module>.SuperFlow.add_report_to_knowledge",
        "<module>.SuperFlow.add_step_to_knowledge"
      ],
      "description": "The central orchestrator that coordinates planning, execution of sub-flows, updating, reporting, and finalizing; it interacts with PlannerAgent, ReportAgent, NotifyAgent, sub_flow_factory, and external tools; maintains parallel execution groups and knowledge memory, and exposes a run method that yields AgentEvent objects."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "Enumeration of the PlanActFlow’s lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING), used to drive the flow’s state machine."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    MESSAGE = \"message\"\n    SHELL = \"shell\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "Enumeration of sub-planner types (MESSAGE, SHELL, SEARCH, FILE), indicating different planning synergies available to the planning component."
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "PlanActFlow",
      "qualname": "<module>.PlanActFlow",
      "source": "class PlanActFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"plan_act\"\n    description = \"计划-执行流程：先创建计划，然后逐步执行，支持动态更新计划\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.PlanActFlow.__init__",
        "<module>.PlanActFlow.run",
        "<module>.PlanActFlow.is_idle",
        "<module>.PlanActFlow._show_plan"
      ],
      "description": "Core orchestrator that coordinates planning and execution of a user request; composes PlannerAgent, ExecutionAgent, and NotifyAgent, manages a multi-state workflow, handles interruptions via rollbacks, and emits events to downstream consumers while maintaining plan state and logs."
    }
  ]
}