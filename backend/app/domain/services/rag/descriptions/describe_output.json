{
  "files": [
    {
      "file": "flows/base.py",
      "description": "该文件定义两个抽象基类：BaseFlow 和 BaseSubFlow，提供顶层流程与子规划器流程的统一接口与契约。通过使用 ABC/abstractmethod，强制子类实现核心方法 run 和 is_idle，并通过 flow_id/description 提供可识别的流程标识与描述信息。BaseFlow 负责管理一个 Agent 实例并校验唯一标识 flow_id，提供获取描述的通用实现。BaseSubFlow 负责注入并保存一组外部工具与依赖（如 LLM、沙盒、浏览器、搜索引擎及多种专用 LLM），定义执行单步计划的接口与空闲性判断。文件中的类型引用涵盖领域模型（AgentEvent、Agent、Plan、Step、Memory）以及外部服务接口（LLM、Sandbox、Browser、SearchEngine 等），以便在具体实现中解耦各依赖并组合使用。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "description": "SubPlannerFlow 文件级别简介 该文件实现一个通用的子计划流 SubPlannerFlow，用来从父计划的描述生成子计划、逐步执行并在必要时更新，最终输出执行报告。它通过 SubPlannerAgent 进行子计划的生成与管理，通过 ExecutionAgent 执行子计划的步骤，并对系统提示、内存等进行动态更新与维护。依赖大量外部组件与服务（多模态与语言模型、沙箱、浏览器、搜索引擎等）以及内建的 Memory、PromptManager、日志框架，负责跨代理协作和事件驱动的流程控制。流程通过多种事件对象（如 PlanCreatedEvent、MessageEvent、ToolCallingEvent、ToolCalledEvent、PlanUpdatedEvent、PlanCompletedEvent、ReportEvent、DoneEvent）进行状态传递与对外输出。内部实现一个状态机，覆盖从 idle、planning、executing、updating、reporting 到 completed 的生命周期，并在关键节点记录详细日志以便调试与追踪。"
    },
    {
      "file": "flows/default_flow.py",
      "description": "该文件实现默认的子流程（default flow），负责从父计划中获取输入描述，创建子计划并逐步执行，直至生成最终报告并标记为完成。核心类型包括 AgentStatus 枚举、DefaultFlow 类，以及与 SubPlannerAgent、ExecutionAgent 的协作关系，辅以 Memory、PromptManager、各种 llm/外部组件（Sandbox、Browser、SearchEngine 等）来驱动对话、计划与执行过程。代码大量使用异步生成器和事件流来逐步暴露子流程中的计划创建、执行、更新与报告等阶段。日志记录由专用的 sub_planner_flow_logger 完成，便于对比不同任务类型的子流程行为。该实现依赖外部领域模型（Plan、Step、事件模型）与外部代理服务，并与父计划的输入/输出紧密交互，通过更新系统提示词、汇总执行结果以及更新子计划来实现自适应执行。最后，通过返回 PlanCompletedEvent 或 ReportEvent 与父流程进行协作。"
    },
    {
      "file": "flows/search_flow.py",
      "description": "该文件实现了一个基于多步 gap 反射的搜索流程 SearchFlow，作为 BaseSubFlow 的子类，负责从 gap 的生成、搜索、打分、分析与反思，到知识库的整理以及最终答案的生成与汇报的完整流程。它通过一个 ExecutionAgent（执行器）与一个外部 LLM 进行交互，动态维护知识库 self.knowledge、处理的 gap 集合 self.processed_gaps，以及最大迭代次数 max_iterations。核心能力包括 gap 生成、对每个 gap 的检索与评估、对失败结果的分析与反射生成新 gap，以及将最终答案综合自知识库。为确保可控性，代码中将并发改为串行执行，且强调 use of format_search_result 规范化输出以填充知识库。该模块与 prompts、LLM、执行器、计划/步骤模型等组件协作密切，形成端到端的问题求解流程。"
    },
    {
      "file": "flows/code_flow.py",
      "description": "CodeFlow子流程实现，Flows/code_flow.py 定义了一个名为 CodeFlow 的子流程，用于从父计划中创建子计划并逐步执行，支持在执行过程中动态更新子计划。该文件负责与多种外部组件协作：LLM、沙箱、浏览器，以及可选的搜索引擎和其他专用LLM，大量使用 PromptManager 来管理系统提示词、内存和时间信息，并通过自定义日志记录器记录详细运行轨迹。内部实现了一个简单的状态机（AgentStatus），覆盖从空闲、规划、执行、更新、报告到完成的生命周期。CodeFlow 在初始化阶段创建 SubPlannerAgent 与 ExecutionAgent，确保子计划的生成、执行与结果汇总能够并行协同完成。在运行过程中，它会处理子计划的创建、逐步执行、步骤总结、计划更新以及最终报告的生成，并通过事件流向外部系统暴露执行状态和结果（如 PlanCompletedEvent、ReportEvent 等）。此外，文件还提供了一个调试辅助方法 _show_plan，用于输出当前子计划的详细信息，便于诊断与追踪。"
    },
    {
      "file": "flows/factory.py",
      "description": "该文件实现 FlowFactory 与 SubFlowFactory，用于管理和创建流程（flow）与子流程（sub-flow）的注册、查询与实例化。FlowFactory 维护一个流类型注册表，支持注册新的 Flow、根据 flow_id 动态创建 Flow 实例，并暴露获取可用 Flow 列表、查询是否存在某个 Flow、获取特定 Flow 类的方法；在创建时会将 Agent、LLM、Sandbox、Browser、SearchEngine 等外部依赖注入到实例中。SubFlowFactory 提供对 SubFlow 的注册与创建，包含将某些任务类型重定向到默认通用流的逻辑，并提供获取可用子流程及按需生成枚举类型的能力，同时使用专用日志器进行详细记录。该模块依赖多种域模型与外部组件（Agent、LLM 系列、Sandbox、Browser、SearchEngine 等），并与具体 Flow 实现（PlanActFlow、SimpleChatFlow、DefaultFlow、SearchFlow、CodeFlow、SuperFlow 等）协作。文件还暴露全局实例 flow_factory 与 sub_flow_factory，供系统其他部分直接使用，并对 SubFlowFactory 的日志记录使用 setup_sub_planner_flow_logger 进行专项日志处理。附带的 SubPlannerType 枚举为子流程类型提供了一个初步的类型定义与映射支持。"
    },
    {
      "file": "flows/simple_chat.py",
      "description": "[文件级别简介] 该文件实现一个简单聊天流程 SimpleChatFlow，直接与大语言模型（LLM）对话，不进行计划和执行。它继承自 BaseFlow，整合了 Agent、文本/音频/图片/视频等多种 LLM，以及沙盒、浏览器和可选的搜索引擎等外部组件，负责在接收到用户输入时产生相应的事件流。流程通过异步生成器 run 来构造提示、调用 llm.ask 获取回复，并将回复通过 MessageEvent 发送出去，最终以 DoneEvent 表示完成。文件中还包含状态管理（_is_idle）用于指示流程的空闲与否，并在关键节点记录日志以便调试。总体上，该实现服务于简单的问答场景，未涉及复杂的规划或任务执行。"
    },
    {
      "file": "flows/super_flow.py",
      "description": "该文件实现一个名为 SuperFlow 的高级流程编排器，用以在单个任务中组合并管理多个子规划器的执行。它首先定义了一组流程状态枚举 FlowStatus，用以表示流程生命周期的不同阶段。SuperFlow 在初始化时会搭建必要的外部依赖和内部记忆结构，创建 PlannerAgent、ReportAgent、NotifyAgent，以及用于创建子流程的 sub_flow_factory，并初始化日志系统以便详细跟踪执行过程。该类通过 run 方法实现一个以事件驱动的主循环，涵盖从用户输入的规划、并发执行子任务、过程更新到最终报告的完整流程，并对外暴露的接口提供丰富的事件流和日志信息。代码中还处理对外部服务（如 LLM、Sandbox、Browser、SearchEngine 等）的协作，维护计划与知识记忆，并在需要时将简洁的通知与报告信息传递给用户。通过这些协作，该文件实现了一个可扩展、可并发执行、可追溯的复杂任务流程管理系统。"
    },
    {
      "file": "flows/plan_act.py",
      "description": "该文件实现一个面向代理的“计划-执行”流程 PlanActFlow，负责将用户消息转化为计划、逐步执行并在必要时更新计划直至完成。它通过组合 PlannerAgent、ExecutionAgent 与 NotifyAgent，协同使用多种大模型及外部能力（Sandbox、Browser、SearchEngine 等）完成整个工作流，并结合 Memory 进行状态与历史上下文的管理与记忆压缩。文件中定义了 AgentStatus 与 SubPlannerType 两个枚举，用于表示流程状态及子规划器类型，便于流程控制与扩展。PlanActFlow 会记录专用日志、处理流程中的中断回滚、以及对计划和步骤的日志化输出，最终输出 PlanCompletedEvent 与 DoneEvent。此外，该模块依赖于 app.domain 的一系列模型、服务与外部接口，并与外部日志系统进行交互以实现可观测性和排错能力。"
    }
  ],
  "functions": [
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.__init__",
      "source": "    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "接收 agent 与可选参数，保存 agent 并校验 flow_id 已定义；若未定义则抛出 ValueError。输入为 agent 与其他 kwargs，输出为无（初始化副作用，状态更新为对象实例化）。调用关系：在具体子类实例化时被调用以完成初始化并确保 flow_id 合法性。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "抽象异步方法，定义输入 message: str，输出为 AsyncGenerator[AgentEvent, None]，表示执行过程产生的事件流，具体实现由子类提供。副作用：在实现中产生事件序列并通过生成器返回。调用关系：由外部流程驱动方迭代该事件序列。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "抽象方法，返回布尔值表示当前 flow 是否处于空闲状态。输入输出：无直接输入，返回布尔；副作用：由具体实现决定。调用关系：由外部逻辑用于调度或切换流程。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回该 Flow 类的唯一标识符 flow_id。输入输出：无参数，输出字符串。调用关系：被外部系统用于识别与路由不同的 Flow。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回 Flow 的描述信息，若未定义 description 则返回默认 \"Flow {flow_id}\"。输入输出：无参数，输出字符串。调用关系：被外部系统用于显示或日志中对 Flow 的描述。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化子规划器流程的依赖注入，接受 llm、sandbox、browser、search_engine、audio_llm、image_llm、video_llm、reason_llm、task_type 等参数并保存为实例属性。输入输出：无实际输出，副作用为设置对象状态。调用关系：在具体子规划器实例化时被调用以提供所需工具与上下文。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.run",
      "source": "    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "抽象异步方法，输入为 parent_plan、parent_step、parent_memory 和 task_type，输出为 AsyncGenerator[AgentEvent, None]，描述执行父计划中单个步骤并产生事件的过程；具体实现将创建子规划器、执行并产出最终报告。调用关系：由父流程触发以执行子步骤并产生事件流。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "抽象方法，返回布尔值表示子规划器当前是否空闲。输入输出：无输入，输出布尔。调用关系：由调度器用于判断是否可继续或等待。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回该子流类的唯一标识符 flow_id。输入输出：无参数，输出字符串。调用关系：外部系统用于识别子流类型。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回子流的描述信息，若未定义 description，则默认 Flow {flow_id}。输入输出：无参数，输出字符串。调用关系：用于显示/日志。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构造 SubPlannerFlow，接收核心组件（llm、sandbox、browser、可选的 search_engine/audio/image/video/reason_llm、task_type 等），初始化专用日志、内存与父类，创建 SubPlannerAgent 与 ExecutionAgent，并将初始状态设为 IDLE；如创建失败则记录错误并抛出异常。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步生成器，接收父计划、父步骤、父记忆与任务类型，执行子计划的创建、执行、更新与报告等完整流程，并在各阶段不断产出事件以供外部消费；期间会更新系统提示、内存与计划状态，涉及对子计划、执行代理与提示管理的多次交互。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "检查当前状态是否为 IDLE，用于判断是否可进入新一轮流程。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "打印并输出子计划的关键信息（ID、目标、步骤及状态），用于调试与审计。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化默认子流程，接收各种 llm/外部组件与任务类型参数，创建并绑定 SubPlannerAgent 与 ExecutionAgent，配置专用日志记录器，初始化执行状态与内存存储，并对创建过程中的异常进行日志记录与抛出。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "以异步生成器形式执行子计划流程，输入为父计划/步骤/记忆及任务类型；内部包含系统提示词更新、子计划创建、逐步执行、计划更新与总结、以及最终报告的生成与产出控制，期间会对事件进行日志记录并与父流程进行数据交换。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "指示当前流程是否处于空闲状态，便于上层调度与状态检查。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "打印并输出当前子计划的详细信息（ID、目标、步骤及各自状态/结果），用于调试与跟踪当前计划的快照。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化搜索流程对象，保存传入的服务引用、初始化知识库、设定最大迭代次数与已处理 gap 集合，并将状态设为 idle，为后续 run 做准备。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.is_idle",
      "source": "    def is_idle(self):\n        return self.status == \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前流程是否处于空闲状态，返回布尔值。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.run",
      "source": "    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "作为统一入口的异步生成器，适配不同参数风格，负责创建执行器、生成全局问题的初始阶段、逐轮处理 gaps、调用搜索与评估子流程、在失败时进行分析与反射，并最终生成并输出最终答案。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.select_scoring_mode",
      "source": "    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "根据全局问题通过 LLM 选择需要的评估类型列表（如 definitive、freshness、file 等），并返回该模式列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_gaps",
      "source": "    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "基于全局问题和当前时间等信息，向 LLM 请求重新表述并生成一组 gap（检索子问题），返回 gaps 列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.search_gap",
      "source": "    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "将 gap 结合当前知识库与执行器的能力构造检索任务的提示并通过执行器执行一个最小 Plan 的 Step，返回包含 gap 与检索结果的字典。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.score_gap",
      "source": "    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "使用多个评估类型对检索结果进行打分，逐条向 LLM 提问并解析返回的通过情况，最终返回是否通过与综合原因（原因字符串）。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._get_prompts",
      "source": "    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "根据评估类型构造系统提示和用户提示的模板文本，用于 score_gap 的后续 LLM 调用。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.analyze_gap",
      "source": "    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "当某个 gap 未通过打分时，调用 LLM 对失败原因进行简要分析并返回文本。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap",
      "source": "    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "基于 gap 与错误原因，利用 LLM 生成更新的更精准 gap（新的检索子问题），以待下一轮尝试；返回新 gap 列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap_batch",
      "source": "    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "针对本轮所有未解决的 gap，批量整合信息后请求 LLM 生成一组新的 gap，返回新 gap 的列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._filter_and_update_gaps",
      "source": "    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "对 gap 及新产生的 gap 进行去重和过滤，并更新已处理的 gap 集合，返回未处理的新 gap 列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.format_search_result",
      "source": "    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "将检索结果的多种类型（字符串、字典、列表等）规范化为可读文本，优先使用 result/summary 等字段，便于后续填充知识库。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_final_answer",
      "source": "    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "基于全局问题和知识库，调用 LLM 生成最终答案，并指示是否还需补充信息（need_more），返回 (答案, need_more)。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.summarize_execution",
      "source": "    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "产出一个简要的执行摘要事件流，便于外部查看执行过程。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_report",
      "source": "    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "产出一个最终报告事件流，用于汇总知识库及执行过程中的关键信息。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 CodeFlow 实例，设置专用日志、创建 SubPlannerAgent 和 ExecutionAgent、初始化内存与状态，并将传入的外部组件（LLM、Sandbox、Browser、SearchEngine 等）注入到子组件中，准备系统 prompts。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "作为异步生成器执行子计划流程，包括更新系统提示词、创建子计划、执行与更新子计划、汇总与生成最终报告，并根据状态机在不同阶段产出相应事件。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前流程是否处于空闲状态，返回布尔值。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "调试输出当前子计划的详细信息（ID、目标、步骤及状态等）。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 FlowFactory，创建内部注册表并注册默认的 Flow 类型。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册 PlanActFlow、SimpleChatFlow，以及为避免循环导入而延迟导入的 SuperFlow。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "校验给定 Flow 类是否继承自 BaseFlow，获取 flow_id 并注册；如已存在同名则发出警告。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.create_flow",
      "source": "    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据 flow_id 创建对应的 Flow 实例，传入 Agent、LLM、音视频相关 LLM、Sandbox、Browser、SearchEngine 等外部依赖及附加参数；未注册时抛出异常并给出可用类型清单。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "返回所有已注册 Flow 的 flow_id、名称、描述信息的列表。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "判断指定的 flow_id 是否已注册。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "返回指定 flow_id 对应的 Flow 类（若不存在则返回 None）。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 SubFlowFactory，设置专用日志记录器，注册默认子流程类型并输出初始化日志。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册 DefaultFlow、SearchFlow、CodeFlow 等默认子流程类型。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "校验给定 SubFlow 类是否继承自 BaseSubFlow，获取 flow_id 并注册；如重复则记录警告。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.create_flow",
      "source": "    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据传入的任务类型 task_type 和上下文参数（llm、sandbox、browser、search_engine、audio_llm、image_llm、video_llm、reason_llm）创建对应的子流程实例；包含对 flow_type 的重定向逻辑与详细日志。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "返回所有已注册子流程的 flow_id、名称、描述信息。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows_enum",
      "source": "    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据可用子流程生成一个新的 Enum 类并返回，用于外部使用。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "判断指定的 flow_id 是否已注册。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "返回指定 flow_id 对应的子流程类（若不存在则返回 None）。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "在构造时绑定 Agent、多个 LLM 实例以及沙盒、浏览器和可选的搜索引擎等外部依赖，初始化内部状态并调用父类构造，同时记录调试信息。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "以异步生成器接收用户消息，设置忙碌状态，构造提示后调用 llm.ask 获取回复，并将结果以 MessageEvent 发送；若出错则发送包含错误信息的 MessageEvent，最终回到空闲状态并发出 DoneEvent。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "返回当前流程的空闲状态（基于 _is_idle 的布尔值）。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 SuperFlow，设置状态、日志器，并保存多种外部依赖（llm、sandbox、browser、search_engine 等）；创建 PlannerAgent、ReportAgent、NotifyAgent，以及 sub_flow_factory，并初始化记忆与并发执行相关的数据结构。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._determine_task_type",
      "source": "    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "静态方法根据步骤描述推断任务类型（code、search、reasoning、file），作为后续创建子流程的依据，默认返回 \"search\"。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.execute_step",
      "source": "    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "对传入的 Step 根据其 sub_flow_type 或描述推断任务类型，创建对应的子流程并执行，输出 StepStartedEvent/StepFailedEvent/PauseEvent/StepCompletedEvent，以及对 ReportEvent 的简化转发；在异常情况下产出 StepFailedEvent 并返回。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._build_parallel_execution_groups",
      "source": "    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构建并发执行组，按 sub_plan_step 的顺序将步骤分组，处理缺少 subplan_step、数字转换失败、顺序冲突等异常，最终将分组结果转换为 deque 存储并供后续执行使用。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "负责整个事件驱动循环的核心入口，处理 IDLE/PLANNING/EXECUTING/UPDATING/REPORTING/COMPLETED 等状态转换，调用 notifier、planner_agent、report_agent、execute_step，并将结果通过事件流向外部，同时维护知识记忆与计划更新。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "返回当前状态是否为 IDLE，作为外部查询流程是否空闲的简单接口。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "将计划的关键信息（ID、目标、步骤及状态等）输出到日志，辅助调试与追踪。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_report_to_knowledge",
      "source": "    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "将当前报告作为助手消息追加到知识记忆中，供后续推理与查询使用。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_step_to_knowledge",
      "source": "    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "将当前步骤描述作为用户消息追加到知识记忆中，帮助形成上下文记忆。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 PlanActFlow，绑定 Agent 与多模态 LLM 组件，创建 PlannerAgent、ExecutionAgent、NotifyAgent，并设置专用日志记录器与初始状态，准备后续的规划与执行流程。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "以异步生成器方式处理用户消息，完成从规划、执行、更新到最终报告的完整流程并在各阶段产出事件；支持中断回滚并在结束时返回 PlanCompletedEvent 与 DoneEvent。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前状态是否为 IDLE，供外部或内部调用以决定是否进入新一轮流程。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "将当前计划的基本信息（ID、目标、步骤详情等）打印到日志，帮助调试和追踪计划内容。"
    }
  ],
  "classes": [
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseFlow",
      "qualname": "<module>.BaseFlow",
      "source": "class BaseFlow(ABC):\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n    \n    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n\n    @abstractmethod\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n    \n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "methods": [
        "<module>.BaseFlow.__init__",
        "<module>.BaseFlow.run",
        "<module>.BaseFlow.is_idle",
        "<module>.BaseFlow.get_flow_id",
        "<module>.BaseFlow.get_description"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseSubFlow",
      "qualname": "<module>.BaseSubFlow",
      "source": "class BaseSubFlow(ABC):\n    \"\"\"\n    子规划器流程的基础接口类\n    定义了子规划器流程必须实现的核心方法\n    \"\"\"\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n\n    # 初始化SubFlow可用的基础设施\n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n\n    @abstractmethod\n    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n\n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "methods": [
        "<module>.BaseSubFlow.__init__",
        "<module>.BaseSubFlow.run",
        "<module>.BaseSubFlow.is_idle",
        "<module>.BaseSubFlow.get_flow_id",
        "<module>.BaseSubFlow.get_description"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "枚举类型，定义 SubPlannerFlow 的工作状态（IDLE、PLANNING、EXECUTING、COMPLETED、UPDATING、REPORTING），用于驱动流程的状态机与分支行为。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "SubPlannerFlow",
      "qualname": "<module>.SubPlannerFlow",
      "source": "class SubPlannerFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"general\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.SubPlannerFlow.__init__",
        "<module>.SubPlannerFlow.run",
        "<module>.SubPlannerFlow.is_idle",
        "<module>.SubPlannerFlow._show_plan"
      ],
      "description": "核心流程实现，负责从父计划描述创建子计划、执行与更新子计划、汇总并输出最终报告；并通过 SubPlannerAgent 与 ExecutionAgent 协同工作，结合 PromptManager 与 Memory 维护系统提示与执行上下文，输出一系列事件以驱动外部消费和日志记录。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "DefaultFlow",
      "qualname": "<module>.DefaultFlow",
      "source": "class DefaultFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"default\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.DefaultFlow.__init__",
        "<module>.DefaultFlow.run",
        "<module>.DefaultFlow.is_idle",
        "<module>.DefaultFlow._show_plan"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/search_flow.py",
      "name": "SearchFlow",
      "qualname": "<module>.SearchFlow",
      "source": "class SearchFlow(BaseSubFlow):\n    flow_id = \"search\"\n    description = \"多步gap反射搜索流程\"\n\n    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n\n    def is_idle(self):\n        return self.status == \"idle\"\n\n    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n\n    # ========== 以下为各模块实现 ==========\n\n    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n\n    #生成gap\n    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n\n    #由run方法中串行调用，利用executor搜索单个gap\n    # async def search_gap(self, gap: str) -> dict:\n    #     #print(\"search_gap 搜索问题 运行到了\")\n    #     # 1. 构造一个step\n    #     # step = Step(\n    #     #     id=\"search_gap\",\n    #     #     description=f\"请使用搜索工具检索以下内容：{gap}\",\n    #     #     status=ExecutionStatus.PENDING\n    #     # )\n    #     step = Step(\n    #         id=\"search_gap\",\n    #         description=(\n    #             f\"You have access to all available tools, including search engines, web browsers, code execution, and multimedia analysis.\"\n    #             f\"\\nPlease select the most appropriate tool(s) to solve the following sub-question. \"\n    #             f\"Actively call the needed tools, integrate their output, and provide a clear answer.\"\n    #             f\"If you encounter a question that needs reading files(pdf/word/txt) to obtain the answer, you should try to download the file from the internet for more accurate answers.\"\n    #             f\"If you are required to find answers from related essays, articles or books, you should download them and check the file by reading them locally.\"\n    #             f\"In most conditions, searching information about content of an article/book/essay is not a good idea, not much information can be found online, download and read the file if needed.\"\n    #             f\"\\nSub-question: {gap}\"\n    #         ),\n    #         status=ExecutionStatus.PENDING\n    #     )\n    #\n    #     # 2. 构造一个最小Plan\n    #     plan = Plan(\n    #         id=\"search_gap_plan\",\n    #         title=\"Search Gap Task\",\n    #         goal=gap,\n    #         steps=[step]\n    #     )\n    #     all_messages = []\n    #     final_result = None\n    #     final_error = None\n    #\n    #     # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n    #     async for event in self.executor.execute_step(plan, step, gap):\n    #         if hasattr(event, \"message\"):\n    #             all_messages.append(event.message)\n    #         if isinstance(event, StepCompletedEvent):\n    #             # 把最终 result 也放到 messages 最后\n    #             all_messages.append(event.step.result)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #         elif isinstance(event, StepFailedEvent):\n    #             # 错误处理\n    #             all_messages.append(event.step.error)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #\n    #\n    #     # 4. fallback，兜底\n    #     #print(\"如果gap no result found，以下会被打印：\")\n    #     #print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n    #     # return {\"gap\": gap, \"error\": \"No result\"}\n    #     all_messages.append(\"No result\")\n    #     return {\"gap\": gap, \"result\": all_messages}\n\n    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n\n\n    #为gap执行结果打分，打分为boolean值\n    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n\n\n    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n\n\n    #analyze分析本次gap执行错误的原因\n    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n\n    #reflect负责根据失败原因提供新的gap\n    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n\n    #reflect batch负责一整轮gap结束后的反思以及提供新gap，实现一个简单的没有plan的递进\n    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n\n\n    #为避免出现过于相似或者重复的gap，generate后使用filter去重\n    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n\n    #此处规范化result，保证知识库内信息不为空\n    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n\n    #最后一步，生成最终报告\n    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n\n    # ========== 可选 summary/report 接口 ==========\n    # 两个方法视情况使用，目前在代码中并未用到\n\n    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n        # 可以输出 self.knowledge 等\n\n    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "methods": [
        "<module>.SearchFlow.__init__",
        "<module>.SearchFlow.is_idle",
        "<module>.SearchFlow.run",
        "<module>.SearchFlow.select_scoring_mode",
        "<module>.SearchFlow.generate_gaps",
        "<module>.SearchFlow.search_gap",
        "<module>.SearchFlow.score_gap",
        "<module>.SearchFlow._get_prompts",
        "<module>.SearchFlow.analyze_gap",
        "<module>.SearchFlow.reflect_gap",
        "<module>.SearchFlow.reflect_gap_batch",
        "<module>.SearchFlow._filter_and_update_gaps",
        "<module>.SearchFlow.format_search_result",
        "<module>.SearchFlow.generate_final_answer",
        "<module>.SearchFlow.summarize_execution",
        "<module>.SearchFlow.generate_report"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "CodeFlow",
      "qualname": "<module>.CodeFlow",
      "source": "class CodeFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"code\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.CodeFlow.__init__",
        "<module>.CodeFlow.run",
        "<module>.CodeFlow.is_idle",
        "<module>.CodeFlow._show_plan"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "FlowFactory",
      "qualname": "<module>.FlowFactory",
      "source": "class FlowFactory:\n    \"\"\"Flow工厂类,负责管理和创建不同类型的flow\"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n    \n    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n    \n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.FlowFactory.__init__",
        "<module>.FlowFactory._register_default_flows",
        "<module>.FlowFactory.register_flow",
        "<module>.FlowFactory.create_flow",
        "<module>.FlowFactory.get_available_flows",
        "<module>.FlowFactory.has_flow",
        "<module>.FlowFactory.get_flow_class"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    CODE = \"code\"\n    REASONING = \"reasoning\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubFlowFactory",
      "qualname": "<module>.SubFlowFactory",
      "source": "class SubFlowFactory:\n    \"\"\"\n    子流程工厂类\n    负责创建和管理所有子流程实例\n    \"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n    \n    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n\n    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n\n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.SubFlowFactory.__init__",
        "<module>.SubFlowFactory._register_default_flows",
        "<module>.SubFlowFactory.register_flow",
        "<module>.SubFlowFactory.create_flow",
        "<module>.SubFlowFactory.get_available_flows",
        "<module>.SubFlowFactory.get_available_flows_enum",
        "<module>.SubFlowFactory.has_flow",
        "<module>.SubFlowFactory.get_flow_class"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/simple_chat.py",
      "name": "SimpleChatFlow",
      "qualname": "<module>.SimpleChatFlow",
      "source": "class SimpleChatFlow(BaseFlow):\n    \"\"\"简单聊天流程：直接与LLM对话，不进行计划和执行\"\"\"\n    \n    # 定义flow的唯一标识符\n    flow_id = \"simple_chat\"\n    description = \"简单聊天流程：直接与LLM对话，适用于简单的问答场景\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n    \n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n    \n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "methods": [
        "<module>.SimpleChatFlow.__init__",
        "<module>.SimpleChatFlow.run",
        "<module>.SimpleChatFlow.is_idle"
      ],
      "description": "SimpleChatFlow 是一个实现简单聊天流程的类，核心职责是直接与 LLM 交互并通过事件流输出回复；它维护对多种外部组件的引用与一个用于表示是否空闲的状态标记，并提供 run 与 __init__ 等关键方法以支持流程运行与初始化。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "FlowStatus",
      "qualname": "<module>.FlowStatus",
      "source": "class FlowStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "SuperFlow",
      "qualname": "<module>.SuperFlow",
      "source": "class SuperFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"TreeFLow\"\n    description = \"a flow that uses multiple planners to handle complex tasks\"\n\n    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n\n\n    @staticmethod\n    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n\n\n    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n\n\n    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n\n    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n\n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n\n    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n\n    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "methods": [
        "<module>.SuperFlow.__init__",
        "<module>.SuperFlow._determine_task_type",
        "<module>.SuperFlow.execute_step",
        "<module>.SuperFlow._build_parallel_execution_groups",
        "<module>.SuperFlow.run",
        "<module>.SuperFlow.is_idle",
        "<module>.SuperFlow._show_plan",
        "<module>.SuperFlow.add_report_to_knowledge",
        "<module>.SuperFlow.add_step_to_knowledge"
      ],
      "description": ""
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "定义 PlanActFlow 的工作状态集合（IDLE、PLANNING、EXECUTING、COMPLETED、UPDATING、REPORTING），用于驱动流程的状态机与转场逻辑。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    MESSAGE = \"message\"\n    SHELL = \"shell\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "定义子规划器类型枚举（MESSAGE、SHELL、SEARCH、FILE），用于区分不同的计划拆解与执行路径。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "PlanActFlow",
      "qualname": "<module>.PlanActFlow",
      "source": "class PlanActFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"plan_act\"\n    description = \"计划-执行流程：先创建计划，然后逐步执行，支持动态更新计划\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.PlanActFlow.__init__",
        "<module>.PlanActFlow.run",
        "<module>.PlanActFlow.is_idle",
        "<module>.PlanActFlow._show_plan"
      ],
      "description": "核心流程控制类，协调 PlannerAgent、ExecutionAgent 与 NotifyAgent 的交互，处理从接收用户消息到最终完成计划执行的全流程，包含状态转换、事件流输出与日志记录。"
    }
  ]
}