{
  "files": [
    {
      "file": "flows/base.py",
      "description": "该文件定义了两个抽象基类，用于规范系统中各种 flow 的实现和协作。BaseFlow 负责顶层流程的接口与约束，要求子类实现异步执行逻辑并提供 flow 的唯一标识与描述。BaseSubFlow 提供子规划器流程的基础接口，支持通过注入多种外部能力（如大语言模型、沙箱、浏览器、搜索引擎及多种专用模型）来执行计划中的单步任务。初始化阶段，BaseFlow 会验证 flow_id 的定义并保存 Agent 引用，确保每个 flow 拥有唯一标识与可操作的代理对象。两个基类都明确了输入输出类型：run 方法返回一个 AsyncGenerator[AgentEvent, None] 的事件流，用于与上层规划器/子规划器进行协作。文件中的类型引用涉及领域模型（AgentEvent、Agent、Plan、Step、Memory）以及多种外部接口（LLM、Sandbox、Browser、SearchEngine 等），体现了与领域模型和外部能力的协作关系。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "description": "SubPlannerFlow 文件级别简介: - 该文件实现了一个名为 SubPlannerFlow 的子流程控制器，用于从父计划中创建子计划、逐步执行子计划并支持动态更新与最终报告。它继承自 BaseSubFlow，并通过异步生成器 run 方法驱动整个流程的状态机：从规划阶段到执行阶段、再到更新和报告阶段，最后产出完成事件。 - 关键类型包括 AgentStatus 枚举（定义 idle/planning/executing/updating/reporting/completed 等状态）、SubPlannerAgent 与 ExecutionAgent 两个核心代理，以及一系列事件类型（如 PlanCreatedEvent、PlanUpdatedEvent、ToolCallingEvent、ToolCalledEvent、ReportEvent、PlanCompletedEvent、DoneEvent 等）来实现事件驱动的协作。 - 外部依赖覆盖了大型语言模型接口（LLM、AudioLLM、ImageLLM、VideoLLM、ReasonLLM）、沙箱 Sandbox、浏览器 Browser、以及可选的 SearchEngine，且与 Memory、PromptManager、以及日志系统（setup_sub_planner_flow_logger）协同工作，形成完整的流控与记忆/提示词管理链路。 - 与子规划器代理 SubPlannerAgent 和执行代理 ExecutionAgent 协作：前者负责子计划的构建与更新，后者负责逐步执行子计划的各步骤并产出执行相关事件。 - 该模块通过详细的日志记录与系统提示词动态更新，确保在不同任务类型下的可追踪性、可调试性以及对外部工具的安全/可控调用。"
    },
    {
      "file": "flows/default_flow.py",
      "description": "该文件定义了默认子流程（DefaultFlow），作为子计划流的核心编排组件，负责将父计划的一个步骤转化为子计划、执行并动态更新，直到产生最终报告。它通过组合 SubPlannerAgent 和 ExecutionAgent 来完成子计划的规划与执行，并借助 PromptManager 动态调整系统提示词以适应不同任务。文件包含一个 AgentStatus 枚举用于表示不同阶段状态，并通过 setup_sub_planner_flow_logger 提供专用日志记录器进行详细日志记录。核心流程在 run 方法中实现，涵盖创建子计划、执行步骤、汇总总结、更新子计划、生成最终报告等阶段，并在完成时产出 ReportEvent 与 PlanCompletedEvent。此外，文件还提供辅助功能，如 is_idle 判断当前是否处于空闲状态，以及 _show_plan 用于日志输出计划内容，帮助调试与追踪。该实现高度依赖外部组件（LLM、Sandbox、Browser、SearchEngine、PromptManager 等）以及内存存储，以异步生成器的形式协作输出事件流。"
    },
    {
      "file": "flows/search_flow.py",
      "description": "该文件实现了一个基于多步反射的 gap 搜索流程 SearchFlow。核心在于将全局问题分解为多个 gap，逐步用知识库进行回答并在失败时通过分析与反射生成新的 gap，从而迭代完善知识库直至形成最终答案。依赖包括 OpenAI LLM 接口、执行代理 ExecutionAgent、以及统一的 prompts 模板集合 prompt。主要数据结构为 knowledge（包含 gap、summary、raw、iteration 等字段的字典列表）、以及对 gaps 的去重管理 filtered/processed_gaps。整体协作关系是：SearchFlow 通过 llm、executor 和 prompts 共同完成 gap 生成、搜索、打分、反思与最终答案生成等多步流程，并以异步生成器形式输出中间事件。该实现对并发与可复用性有一定考虑（当前改为串行执行，避免 executor 并发导致的流程断裂），并提供辅助方法对结果进行格式化与统一处理。外部协作对象包括 BaseSubFlow、ExecutionAgent、Memory、Plan、Step、事件类及 prompts 模块。"
    },
    {
      "file": "flows/code_flow.py",
      "description": "该文件实现 CodeFlow 子计划的编排逻辑，负责从父计划中产生子计划、逐步执行并根据中间结果动态更新子计划。核心包含对 SubPlannerAgent 与 ExecutionAgent 的组合利用，以及对外部提示管理、日志记录和记忆存储的协作，支撑“先规划、再执行、必要时更新、最后汇报”的工作流。它定义了一个状态机（AgentStatus）来驱动流程阶段切换，并处理 PlanCreatedEvent、PlanUpdatedEvent、ReportEvent、PlanCompletedEvent 等多类事件。代码中大量依赖外部组件：LLM、Sandbox、Browser、SearchEngine、PromptManager、Memory 等，以实现子计划的生成、执行与迭代改进。通过异步生成器实现对事件序列的逐步产出，便于上层系统对执行过程进行实时监听和处理。该文件对日志记录高度重视，提供专门的 sub_planner_flow_logger，用以记录每一步的输入、状态变更与结果信息，并在出现异常时进行详细错误追踪。总之，本文件是一个完整的子计划执行流水线的核心实现，负责将父计划拆解为可执行子计划并持续迭代直至完成。"
    },
    {
      "file": "flows/factory.py",
      "description": "FlowFactory 与 SubFlowFactory 的工厂实现，提供对主流程和子流程的注册、查询与创建能力。通过注册表机制，FlowFactory 支持动态扩展新的流程类型，并对外暴露创建流程的入口。SubFlowFactory 则对一组子流程进行注册与派发，并实现针对不同任务类型的重定向逻辑，确保部分类型的子流程能路由到默认实现。两者均通过注入大量外部对象（Agent、LLM 系列、Sandbox、Browser、SearchEngine 等）来构建流程实例，并广泛使用日志记录注册、创建与错误信息。代码还包含全局实例 flow_factory 和 sub_flow_factory，为其他模块提供统一入口，并通过动态导入避免循环依赖。"
    },
    {
      "file": "flows/simple_chat.py",
      "description": "该文件实现 SimpleChatFlow，属于流程框架中的一个简单聊天流程。SimpleChatFlow 直接与大语言模型（LLM）对话，不进行计划与执行。它通过注入的多种外部组件（LLM、AudioLLM、ImageLLM、VideoLLM、ReasonLLM、Sandbox、Browser，以及可选的 SearchEngine）与外部系统协作，并以 Agent 为执行上下文。运行过程以异步生成器输出事件流，先输出用户输入的回复，再输出完成信号；同时通过 _is_idle 字段跟踪流程的工作状态。该实现聚焦简化的对话场景，直接构造提示并调用 llm.ask 获取回复，并对异常情况输出错误信息的消息事件。"
    },
    {
      "file": "flows/super_flow.py",
      "description": "SuperFlow.py 负责实现一个高层次的流程编排器，该流程通过组合多个规划器来处理复杂任务，包含计划、执行、更新以及最终报告的完整生命周期，并通过日志、事件流和记忆模块进行协同。它定义了 FlowStatus 枚举来表示不同阶段的状态，并通过 SuperFlow 类整合 PlannerAgent、ReportAgent、NotifyAgent 等外部组件，以及沙箱、浏览器、搜索引擎等基础设施。该实现初始化时创建规划记忆与知识记忆、构造子流工厂、以及维护并发执行所需的分组结构和活动子流映射，确保在执行过程中能够动态创建和管理子流。 execute_step 方法负责基于步骤描述或显式指定的子流类型创建相应的子流并执行，期间将子流产生的事件转换并过滤，向上层抛出经过简化的 AgentEvent。run 方法实现一个状态机，驱动从规划到执行再到更新和报告的全过程，期间与通知、记忆更新、和最终报告生成等外部组件协同工作并输出事件流。整体设计依赖多类外部实体（LLM、sandbox、browser、search engine、memory、sub-flow factory、sub-flows 等）以实现可扩展的任务分解与并发执行。"
    },
    {
      "file": "flows/plan_act.py",
      "description": "PlanActFlow 文件级别简介： 该文件实现了 PlanActFlow 类，用于管理“计划创建、执行、更新与结果汇报”的完整流程。它通过状态机驱动（IDLE/PLANNING/EXECUTING/UPDATING/REPORTING/COMPLETED），在运行过程中异步产出多种事件（例如 PlanCreatedEvent、PlanUpdatedEvent、PlanCompletedEvent、DoneEvent 等），以供上层系统消费。PlanActFlow 将规划、执行与通知职责分离到 PlannerAgent、ExecutionAgent、NotifyAgent 三个子代理中协作完成，并与外部服务（LLM、Sandbox、Browser、SearchEngine 等）及内存存储进行交互。代码中还定义了 AgentStatus、SubPlannerType 等枚举，用以描述执行状态与子任务类型，并通过专用日志记录器 plan_act_logger 记录详细过程。总体上，该文件承担从用户输入到最终计划完成的端到端流程控制与日志记录，核心在于事件驱动的流程编排与状态迁移。"
    }
  ],
  "functions": {
    "items": [
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseFlow.__init__",
        "source": "    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n",
        "calls": [],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "接收并保存传入的 Agent 实例，若类未定义 flow_id 则抛出 ValueError，确保每个派生 Flow 拥有唯一标识。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseFlow.run",
        "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n",
        "calls": [],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "抽象异步方法，接收输入 message，返回一个异步产生 AgentEvent 的事件流，由子类实现具体的执行逻辑。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
        "calls": [],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "抽象方法，返回布尔值以指示当前 Flow 是否处于空闲状态，由具体实现决定。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseFlow.get_flow_id",
        "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
        "calls": [],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "返回该 Flow 的唯一标识符 flow_id。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseFlow.get_description",
        "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
        "calls": [],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "返回 Flow 的描述文本，如未定义 description 则返回 \"Flow {flow_id}\"。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseSubFlow.__init__",
        "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n",
        "calls": [],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "接受并保存多种外部能力的实例（llm、sandbox、browser、search_engine、audio_llm、image_llm、video_llm、reason_llm，以及可选的 task_type），用于后续子流程的执行和工具协作。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseSubFlow.run",
        "source": "    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n",
        "calls": [],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "抽象异步方法，接收父计划 Plan、父步骤 Step、父记忆 Memory 和任务类型 task_type，返回一个 AsyncGenerator[AgentEvent, None] 的事件流，表示执行单步子规划器的过程与产出。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseSubFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
        "calls": [],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "抽象方法，返回布尔值以指示子流程是否空闲。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseSubFlow.get_flow_id",
        "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
        "calls": [],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "返回该子流程的唯一 flow_id。"
      },
      {
        "file": "flows/base.py",
        "qualname": "flows.base.BaseSubFlow.get_description",
        "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
        "calls": [],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "返回子流程的描述文本，如未定义 description 则返回 \"Flow {flow_id}\"。"
      },
      {
        "file": "flows/sub_planner_flow.py",
        "qualname": "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 SubPlannerFlow 实例，设置专用日志、创建 SubPlannerAgent 和 ExecutionAgent，并将初始状态设为 IDLE，同时记录传入的 LLM/Sandbox/Browser/Tool 等外部依赖与任务类型信息，准备后续流程执行。该方法会维护一个 Memory 实例用于执行结果的缓存与日志输出。"
      },
      {
        "file": "flows/sub_planner_flow.py",
        "qualname": "flows.sub_planner_flow.SubPlannerFlow.run",
        "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "是一个异步生成器，负责从父计划/步骤/记忆出发，驱动子计划的创建、执行、更新直至报告的全流程。它会实时更新系统提示词、根据事件流产出相应的 PlanCreatedEvent、ToolCallingEvent、ToolCalledEvent、MessageEvent、PlanUpdatedEvent、PauseEvent、ReportEvent、PlanCompletedEvent 等，并在不同状态之间进行状态转换与日志记录。"
      },
      {
        "file": "flows/sub_planner_flow.py",
        "qualname": "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "判断当前流程是否处于空闲状态，返回布尔值（是否等于 AgentStatus.IDLE），用于判断是否可以中断或重新开始策略。"
      },
      {
        "file": "flows/sub_planner_flow.py",
        "qualname": "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "将给定计划的关键信息（Plan ID、目标、每个步骤的描述、状态、结果、错误等）以结构化日志形式输出，便于调试与跟踪计划结构。该方法不返回数据，属于内部工具方法。"
      },
      {
        "file": "flows/default_flow.py",
        "qualname": "flows.default_flow.DefaultFlow.__init__",
        "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 DefaultFlow，创建并配置 SubPlannerAgent 与 ExecutionAgent，建立专用日志记录器，初始化执行内存并设置初始状态为 IDLE；调用父类构造并准备后续流程所需的外部依赖与内在组件。可能在创建子代理或执行代理时抛出异常并进行日志记录。"
      },
      {
        "file": "flows/default_flow.py",
        "qualname": "flows.default_flow.DefaultFlow.run",
        "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "作为异步生成器，负责整个子计划的执行生命周期：从 fix 父计划/步骤、更新系统提示词、创建子计划、执行并逐步更新、总结与更新子计划，直到生成最终报告并产出 PlanCompletedEvent；运行过程中会修改状态、维护执行结果并输出相关事件与日志。"
      },
      {
        "file": "flows/default_flow.py",
        "qualname": "flows.default_flow.DefaultFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "判断当前状态是否为 IDLE，以判断是否需要启动新的子流程。"
      },
      {
        "file": "flows/default_flow.py",
        "qualname": "flows.default_flow.DefaultFlow._show_plan",
        "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "将给定计划的详细信息输出到日志，用于调试和跟踪子计划的结构与状态。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.__init__",
        "source": "    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化搜索流程实例，设置知识库、最大迭代次数、已处理 gap 集合与初始状态，准备在 run() 中按需创建执行代理并进入流程。此方法不执行搜索逻辑，主要完成初始参数和状态的准备。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.is_idle",
        "source": "    def is_idle(self):\n        return self.status == \"idle\"\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "判断流程是否处于空闲状态，返回布尔值用于流程调度与重复执行控制。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.run",
        "source": "    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "入口异步生成器，实现整条多步 gap 反射搜索流程的主控制流，包含参数兼容、全局问题获取、评分模式选择、gap 生成与筛选、单轮 gap 搜索/打分、失败反射以及最终答案生成等步骤，并通过事件向外部输出进度与结果。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.select_scoring_mode",
        "source": "    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "根据全局问题通过 llm 选择需要应用的评估类型集合（如 definitive、freshness、file 等），返回一个待评估的类型列表。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.generate_gaps",
        "source": "    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "调用 llm 根据全局问题生成初始的 gap 列表，返回 gaps 字符串列表，解析失败时回退为包含全局问题的单一 gap。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.search_gap",
        "source": "    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "使用当前知识库和 gap 构建执行器任务，调用 executor 执行最小 Plan/Step，返回包含 gap 与结果内容的字典；若执行成功返回结果文本列表，若失败返回包含错误信息的文本列表。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.score_gap",
        "source": "    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "针对一个 gap 的结果，基于提供的 eval_types 逐条发送提示给 llm 进行打分，返回是否通过及累计的理由文本。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow._get_prompts",
        "source": "    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "根据评估类型构建系统提示和用户提示文本，用于 score_gap 的多轮 llm 评估。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.analyze_gap",
        "source": "    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "当一个 gap 的检索结果未能解决问题时，调用 llm 给出简要原因分析，用于随后反思。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.reflect_gap",
        "source": "    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [],
        "description": "根据 gap 与分析原因，使用 llm 生成新的更精准的 gap/检索表达，返回新 gap 列表。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.reflect_gap_batch",
        "source": "    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "针对一轮中多个失败 gap 的分析结果，批量生成新的新 gap 列表，用于后续迭代。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "source": "    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "对 gap 列表进行去重并更新已处理集合，返回未处理的新 gap 列表，支持传入 new_gaps 实现增量更新。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.format_search_result",
        "source": "    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "将搜索/执行结果规范化为可读文本，支持字符串、列表、字典等多种输入形式，并优先展示关键字段如 title、summary、content 等。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.generate_final_answer",
        "source": "    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution"
        ],
        "description": "使用知识库与全局问题，请 llm 给出最终答案，并指明是否还需要补充信息（need_more），返回最终答案及 need_more 标志。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.summarize_execution",
        "source": "    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [],
        "description": "可选的执行摘要接口，当前实现为生成一个简单的消息事件。"
      },
      {
        "file": "flows/search_flow.py",
        "qualname": "flows.search_flow.SearchFlow.generate_report",
        "source": "    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow.execute_step"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "可选的执行报告接口，当前实现为生成一个简单的消息事件。"
      },
      {
        "file": "flows/code_flow.py",
        "qualname": "flows.code_flow.CodeFlow.__init__",
        "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "以 llm、sandbox、browser 等依赖初始化 CodeFlow 实例，创建 SubPlannerAgent 与 ExecutionAgent，配置个性化日志、系统提示与内存，设定初始状态为 IDLE，并在出错时记录并抛出异常。"
      },
      {
        "file": "flows/code_flow.py",
        "qualname": "flows.code_flow.CodeFlow.run",
        "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "作为异步生成器实现对子计划的执行流程，包括子计划创建、步骤执行、动态更新计划以及最终汇报的完整状态机驱动，与 SubPlannerAgent、ExecutionAgent、PromptManager 和 ExecutionResult 进行交互并产出多类型事件。"
      },
      {
        "file": "flows/code_flow.py",
        "qualname": "flows.code_flow.CodeFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "判断当前代理状态是否为 IDLE，用于判断是否可开始新的流程或交由外部逻辑控制执行。"
      },
      {
        "file": "flows/code_flow.py",
        "qualname": "flows.code_flow.CodeFlow._show_plan",
        "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "将当前计划的结构信息（ID、目标、步骤及状态等）输出到日志，便于调试与追踪执行进展。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.__init__",
        "source": "    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 FlowFactory，创建_flow_classes字典并调用_register_default_flows注册默认的 Flow 类型，设置注册表与日志输出。无直接输入，初始化完成后返回 None，具备副作用修改实例状态并注册默认流。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory._register_default_flows",
        "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "注册 PlanActFlow、SimpleChatFlow，并通过动态导入注册 SuperFlow，记录日志以标记已注册的默认流类型。输入输出均为无，副作用为更新_flow_classes并产生日志。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.register_flow",
        "source": "    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "将给定的 Flow 类注册到_flow_classes，校验是否为 BaseFlow 子类且定义了flow_id，若已存在则发出警告并覆盖。输入为 flow_class，输出为 None，副作用是更新注册表并记录日志。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.create_flow",
        "source": "    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "根据flow_id创建对应的 Flow 实例，传入 agent、llm、audio_llm、image_llm、video_llm、reason_llm、sandbox、browser、search_engine 及其他 kwargs；成功返回 Flow 实例，若 flow_id 未注册或创建出错则记录错误并抛出异常。输入参数包括多种依赖对象，输出为 BaseFlow，调用了对应 flow_class 的构造函数。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.get_available_flows",
        "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "获取所有可用的 Flow 类型信息，返回包含 flow_id、name、description 的字典列表。输入无，输出为 List[Dict[str, str]]，副作用为只读遍历注册表。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.has_flow",
        "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [],
        "description": "检查给定 flow_id 是否在注册表中，返回布尔值。输入 flow_id，输出 bool。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.FlowFactory.get_flow_class",
        "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [],
        "description": "获取指定 flow_id 对应的 Flow 类类型，若不存在则返回 None。输入 flow_id，输出 Optional[Type[BaseFlow]]。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.__init__",
        "source": "    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 SubFlowFactory，设置专用日志器并调用_register_default_flows 注册默认子流程类型，输出无，副作用是建立注册表并记录初始化日志。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory._register_default_flows",
        "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "注册 DefaultFlow、SearchFlow、CodeFlow 等默认子流程，输出无，副作用是更新_flow_classes并记录日志。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.register_flow",
        "source": "    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "将给定的 BaseSubFlow 子流程类注册到_flow_classes，校验子类关系与flow_id定义；若重复则记录警告并覆盖。输入为 flow_class，输出为 None，副作用是更新注册表并日志记录。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.create_flow",
        "source": "    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "根据 llm、task_type、sandbox、browser、search_engine 及可选组件参数创建对应的子流程实例；实现对 task_type.value 的重定向逻辑，将特定类型重定向到默认实现，实例化后返回 BaseSubFlow；异常时记录并抛出。输入参数包括 llm、task_type、sandbox、browser、search_engine，以及可选的 audio_llm、image_llm、video_llm、reason_llm，输出一个 BaseSubFlow。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.get_available_flows",
        "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.get_flow_class",
          "flows.factory.FlowFactory.has_flow",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.factory.SubFlowFactory.get_flow_class",
          "flows.factory.SubFlowFactory.has_flow",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "description": "获取所有可用的子流程类型信息，返回包含 flow_id、name、description 的字典列表；输入无，输出 List[Dict[str, str]]。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.get_available_flows_enum",
        "source": "    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "根据可用子流程生成一个动态 Enum 类型，默认名称为 SubPlannerType，成员名为去除 Flow 后缀的类名大写，成员值为 flow_id；返回类型为 type[Enum]。输入可选 enum_name，输出动态生成的 Enum 类。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.has_flow",
        "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [],
        "description": "检查指定 flow_id 是否在子流程注册表中，返回布尔值。输入 flow_id，输出 bool。"
      },
      {
        "file": "flows/factory.py",
        "qualname": "flows.factory.SubFlowFactory.get_flow_class",
        "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
        "calls": [
          "flows.base.BaseFlow.get_description",
          "flows.base.BaseFlow.get_flow_id",
          "flows.base.BaseSubFlow.get_description",
          "flows.base.BaseSubFlow.get_flow_id",
          "flows.factory.FlowFactory._register_default_flows",
          "flows.factory.FlowFactory.get_available_flows",
          "flows.factory.FlowFactory.register_flow",
          "flows.factory.SubFlowFactory._register_default_flows",
          "flows.factory.SubFlowFactory.get_available_flows",
          "flows.factory.SubFlowFactory.register_flow"
        ],
        "called_by": [],
        "description": "获取指定 flow_id 对应的子流程类类型，若不存在返回 None。输入 flow_id，输出 Optional[Type[BaseSubFlow]]。"
      },
      {
        "file": "flows/simple_chat.py",
        "qualname": "flows.simple_chat.SimpleChatFlow.__init__",
        "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 SimpleChatFlow 实例，接收并保存多种外部依赖（LLM、音频/图像/视频 LLM、推理 LLM、Sandbox、Browser，以及可选的 SearchEngine）及 Agent 作为上下文，同时设置初始空闲状态 _is_idle，并记录创建日志。"
      },
      {
        "file": "flows/simple_chat.py",
        "qualname": "flows.simple_chat.SimpleChatFlow.run",
        "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "以异步生成器形式接收用户消息字符串 message，构造提示后通过 llm.ask 获取回复，并通过 yield 输出 MessageEvent；若发生异常则输出包含错误信息的 MessageEvent；执行结束后 yield DoneEvent 并将 _is_idle 设回 True，调用关系主要依赖于 llm.ask 的异步调用并向调用方输出 AgentEvent。"
      },
      {
        "file": "flows/simple_chat.py",
        "qualname": "flows.simple_chat.SimpleChatFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseSubFlow.__init__",
          "flows.code_flow.CodeFlow.__init__",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.search_flow.SearchFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.super_flow.SuperFlow.__init__"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "返回当前流程的空闲状态（_is_idle）的布尔值，不修改内部状态。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.__init__",
        "source": "    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化并配置 SuperFlow 实例，设置初始状态为 IDLE，创建并配置专用日志器，保存 llm、sandbox、browser 等外部依赖，以及可选的音视频/推理 llm；初始化 planner_memory、knowledge_memory，创建 PlannerAgent、ReportAgent、NotifyAgent，并获取 sub_flow_factory 与可用子流类型，初始化并发控制结构和活动子流映射。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow._determine_task_type",
        "source": "    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "根据步骤描述的关键词推断任务类型，返回 code、search、reasoning、file 之一，未匹配时默认返回 search。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.execute_step",
        "source": "    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "为给定步骤创建并执行对应的子流，根据子流事件转换为简化的 AgentEvent（如 StepStartedEvent、StepCompletedEvent、StepFailedEvent、MessageEvent 等），并在异常或暂停等情况下处理状态与输出。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "source": "    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "遍历计划中的步骤，验证并转换 sub_plan_step，按顺序将步骤分组为并发执行组，跳过已完成/失败的步骤，最终返回一个包含执行组的 deque，并记录日志信息。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.run",
        "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "作为主入口的状态机驱动，处理用户消息并在规划、执行、更新、报告等阶段之间转换，调用 PlannerAgent/NotifyAgent/ReportAgent，产生并传播事件，同时更新知识记忆与计划状态。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "判断当前状态是否为 IDLE。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow._show_plan",
        "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "以日志输出当前计划的详细信息（计划ID、目标、每个步骤的描述、状态、结果与错误）。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "source": "    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [],
        "description": "将当前报告内容添加到知识记忆中，记为助手角色。"
      },
      {
        "file": "flows/super_flow.py",
        "qualname": "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "source": "    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseFlow.run",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.base.BaseSubFlow.run",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.FlowFactory.create_flow",
          "flows.factory.SubFlowFactory.__init__",
          "flows.factory.SubFlowFactory.create_flow",
          "flows.factory.SubFlowFactory.get_available_flows_enum",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.run",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "called_by": [],
        "description": "将当前步骤描述添加到知识记忆中，记为用户角色。"
      },
      {
        "file": "flows/plan_act.py",
        "qualname": "flows.plan_act.PlanActFlow.__init__",
        "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow._filter_and_update_gaps",
          "flows.search_flow.SearchFlow._get_prompts",
          "flows.search_flow.SearchFlow.analyze_gap",
          "flows.search_flow.SearchFlow.format_search_result",
          "flows.search_flow.SearchFlow.generate_final_answer",
          "flows.search_flow.SearchFlow.generate_gaps",
          "flows.search_flow.SearchFlow.generate_report",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.search_flow.SearchFlow.reflect_gap",
          "flows.search_flow.SearchFlow.reflect_gap_batch",
          "flows.search_flow.SearchFlow.run",
          "flows.search_flow.SearchFlow.score_gap",
          "flows.search_flow.SearchFlow.search_gap",
          "flows.search_flow.SearchFlow.select_scoring_mode",
          "flows.search_flow.SearchFlow.summarize_execution",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "初始化 PlanActFlow 实例，传入 Agent、各种 llm 与外部服务，创建 PlannerAgent、ExecutionAgent、NotifyAgent，并配置专用日志 plan_act_logger，初始化状态为 IDLE。"
      },
      {
        "file": "flows/plan_act.py",
        "qualname": "flows.plan_act.PlanActFlow.run",
        "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "以异步生成器运行用户消息驱动的计划-执行流程，处理状态机从 PLANNING、EXECUTING、UPDATING、REPORTING 到 COMPLETED 的转变，期间产出并转发各类事件（如 PlanCreatedEvent、ToolCallingEvent、PlanUpdatedEvent、PlanCompletedEvent、DoneEvent 等），并可在中断时回滚子代理状态。"
      },
      {
        "file": "flows/plan_act.py",
        "qualname": "flows.plan_act.PlanActFlow.is_idle",
        "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "返回当前状态是否为 IDLE。"
      },
      {
        "file": "flows/plan_act.py",
        "qualname": "flows.plan_act.PlanActFlow._show_plan",
        "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
        "calls": [
          "flows.base.BaseFlow.__init__",
          "flows.base.BaseFlow.is_idle",
          "flows.base.BaseSubFlow.__init__",
          "flows.base.BaseSubFlow.is_idle",
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.factory.FlowFactory.__init__",
          "flows.factory.SubFlowFactory.__init__",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.search_flow.SearchFlow.__init__",
          "flows.search_flow.SearchFlow.is_idle",
          "flows.simple_chat.SimpleChatFlow.__init__",
          "flows.simple_chat.SimpleChatFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle"
        ],
        "called_by": [
          "flows.code_flow.CodeFlow.__init__",
          "flows.code_flow.CodeFlow._show_plan",
          "flows.code_flow.CodeFlow.is_idle",
          "flows.code_flow.CodeFlow.run",
          "flows.default_flow.DefaultFlow.__init__",
          "flows.default_flow.DefaultFlow._show_plan",
          "flows.default_flow.DefaultFlow.is_idle",
          "flows.default_flow.DefaultFlow.run",
          "flows.plan_act.PlanActFlow.__init__",
          "flows.plan_act.PlanActFlow._show_plan",
          "flows.plan_act.PlanActFlow.is_idle",
          "flows.plan_act.PlanActFlow.run",
          "flows.sub_planner_flow.SubPlannerFlow.__init__",
          "flows.sub_planner_flow.SubPlannerFlow._show_plan",
          "flows.sub_planner_flow.SubPlannerFlow.is_idle",
          "flows.sub_planner_flow.SubPlannerFlow.run",
          "flows.super_flow.SuperFlow.__init__",
          "flows.super_flow.SuperFlow._build_parallel_execution_groups",
          "flows.super_flow.SuperFlow._determine_task_type",
          "flows.super_flow.SuperFlow._show_plan",
          "flows.super_flow.SuperFlow.add_report_to_knowledge",
          "flows.super_flow.SuperFlow.add_step_to_knowledge",
          "flows.super_flow.SuperFlow.execute_step",
          "flows.super_flow.SuperFlow.is_idle",
          "flows.super_flow.SuperFlow.run"
        ],
        "description": "打印并日志输出当前计划的基本信息与各步骤详情，用于调试和审计日志。"
      }
    ]
  }
}