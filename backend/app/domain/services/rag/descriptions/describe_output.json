{
  "files": [
    {
      "file": "flows/base.py",
      "description": "该文件定义了两大抽象基类 BaseFlow 与 BaseSubFlow，构成系统中流程与子流程的核心协议。通过引入 AgentEvent、Agent、Plan、Step、Memory 等领域模型，以及 LLM、Sandbox、Browser、SearchEngine 等外部接口，文件实现了对流程生命周期、唯一标识、描述信息以及依赖注入的约束。BaseFlow 要求具体 flow 实现具备唯一的 flow_id、异步运行入口和闲置检测能力，并提供获取流程描述的通用实现。BaseSubFlow 提供对底层工具链（LLM、沙盒、浏览器、搜索等）的注入能力，并定义子规划器在父计划、父步骤、父记忆上下执行的异步生成器接口，确保子流程能够独立完成计划步骤的执行与结果报告。整体设计实现了可扩展、可测试的流程组件，明确的协作边界和工具耦合点。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "description": "<文件级别简介> 该文件实现一个子计划流（SubPlannerFlow），负责从父计划触发子计划的创建、逐步执行以及动态更新子计划的全过程。它依赖多种外部服务与组件：LLM、Sandbox、Browser、SearchEngine，以及可选的音视频模型和Reasoning LLM，并与 SubPlannerAgent 与 ExecutionAgent 协同工作。通过维护明确的状态机（Idle/Planning/Executing/Updating/Reporting/Completed）并以异步生成器输出 AgentEvent，向上层推送流程进展与结果。核心逻辑包括系统提示词与内存的动态更新、子计划的创建与执行、步骤汇总与计划更新以及最终的执行报告生成。日志记录器通过 setup_sub_planner_flow_logger 细粒度地记录流程阶段与事件，便于调试与跟踪。"
    },
    {
      "file": "flows/default_flow.py",
      "description": "<文件级别简介> 本文件实现一个默认的子流程（DefaultFlow），用于在父流程中先创建子计划再逐步执行，支持在执行过程中动态更新子计划。它通过 SubPlannerAgent 负责子计划的生成与更新，利用 ExecutionAgent 负责执行子计划中的步骤，且可结合多种外部工具与内存存储实现状态追踪。初始化阶段会设置专门的日志记录、装配多种依赖（LLM、Sandbox、Browser、SearchEngine，以及可选的音视频/图像专用 LLM），并将它们注入子规划器与执行器。流程的核心入口是 run 方法，负责更新系统提示词、创建子计划、执行与总结、最终输出报告与完成事件。整体设计通过 PromptManager、Memory、Plan、Step 等领域模型实现解耦协作，并依赖丰富的外部服务实现灵活扩展。"
    },
    {
      "file": "flows/search_flow.py",
      "description": "<该文件实现一个基于多步gap反射的搜索与推理流程，名为 SearchFlow。它从全局问题出发，生成并评估若干 gap，串行执行检索、打分、分析与反射来产生新的子问题，最终汇总形成知识库并生成最终答案。核心实体包括一个与 OpenAI LLM 交互的 llm 客户端、一个用于执行任务的 ExecutionAgent、以及基于提示模板的交互逻辑。它维护一个知识库条目集合、待处理的 gap 集合以及最大迭代次数，确保在回退到串行执行情况下仍能逐轮推进。该实现强调通过 format_search_result 将检索结果规范化后再进行打分与知识库填充，以便 LLM 给出正确结论。整个流程以异步生成器形式暴露，能够向外部发送阶段性事件并在最后返回最终答案。>"
    },
    {
      "file": "flows/code_flow.py",
      "description": "<文件级别简介> 该文件实现了 CodeFlow 子流程，用于对子计划的完整生命周期进行编排：从创建子计划到执行、动态更新以及最终的结果汇报。它依赖领域模型中的 Plan、Step、ExecutionStatus 等，以及一组事件类型（如 PlanCreatedEvent、PlanUpdatedEvent、PlanCompletedEvent、ReportEvent 等）来与其他组件协作。CodeFlow 通过 SubPlannerAgent 负责规划阶段，通过 ExecutionAgent 负责执行阶段，并在过程中不断更新系统提示词与记忆，确保上下文的一致性与可追溯性。日志机制采用专门的子任务日志记录器，并在初始化和运行过程中对外部依赖（LLM、Sandbox、Browser、SearchEngine 等）进行协作与日志记录。运行过程中以异步生成器形式产出事件，便于上层流程进行实时处理与监控。该文件还包含一个简易状态机，通过 AgentStatus 来表示当前阶段状态（IDLE、PLANNING、EXECUTING、UPDATING、REPORTING、COMPLETED）。"
    },
    {
      "file": "flows/factory.py",
      "description": "Flows/factory.py 文件职责概述： 该文件实现了 FlowFactory 和 SubFlowFactory 两个工厂，用以管理和创建系统中的主流程与子流程。 FlowFactory 注册并实例化不同的主流程类（如 PlanActFlow、SimpleChatFlow、SuperFlow 等），并提供查询、注册与获取流程类的接口；SubFlowFactory 则负责子流程的注册、创建以及对某些任务类型的重定向逻辑。 两个工厂都依赖于多种外部抽象（Agent、LLM 组件、Sandbox、Browser、SearchEngine 等）以及各自的流程实现类（BaseFlow/BaseSubFlow 的派生类），并通过日志来跟踪流程创建与注册过程。 同时，该模块定义了 SubPlannerType 枚举用于子流程类型的表示，并暴露全局实例 flow_factory 与 sub_flow_factory 以供全局使用。"
    },
    {
      "file": "flows/simple_chat.py",
      "description": "通过一个简单的聊天流程实现，直接将用户问题发送给 LLM 获取回复，不涉及计划与执行阶段。该模块定义了 SimpleChatFlow 类，作为 BaseFlow 的具体实现，使用了多种外部依赖的接口（LLM 及其变体、Sandbox、Browser、SearchEngine 等）以 support 未来扩展，但在当前实现中主要通过 LLM 完成对话生成。运行时以异步生成器的方式输出事件流，向 Agent 发送 MessageEvent 作为回复，并在结束时发出 DoneEvent，同时通过日志进行跟踪与错误处理。该文件强调简单、直接的对话能力，并提供了 idle 状态的管理接口。与其他模块的协作关系包括与 Agent、LLM 及外部服务的集成，以及通过事件机制向上层传递对话结果。"
    },
    {
      "file": "flows/super_flow.py",
      "description": "该文件实现了一个面向多规划者的超级流程（SuperFlow）的协调器，负责将用户输入转化为可执行的计划、分解为并发/串行的子流程并执行、再汇总成最终报告。它定义了流程状态枚举 FlowStatus，用以跟踪从规划、执行、更新到报告各阶段的生命周期。通过组合 PlannerAgent、ReportAgent、NotifyAgent、以及面向外部工具的内/外部依赖（LLM、Sandbox、Browser、SearchEngine、各种 LLM 模型等），并依赖子流程工厂创建具体的 SubFlow，完成对复杂任务的分解与执行。它维护两个 Memory 实例用于规划记忆与知识记忆，并通过 sub_flow_factory 动态创建子规划器来处理具体的任务类型。同时，它提供运行入口 run，用于处理用户消息并通过事件流向下游组件，涉及大量日志记录与事件转发。总体来说，该文件是系统中负责“从用户输入到最终执行与报告”的核心协调组件，围绕计划、执行、更新和报告四大阶段进行协作与状态管理。"
    },
    {
      "file": "flows/plan_act.py",
      "description": "该文件主要实现了一个计划执行流程（PlanActFlow），负责协调计划的创建、执行、动态更新以及最终报告。核心类型包括AgentStatus和SubPlannerType枚举，定义了代理的状态和子规划器类型，关键类为PlanActFlow，继承自BaseFlow。PlanActFlow集成了多个代理对象（PlannerAgent、ExecutionAgent、NotifyAgent）以及多种外部依赖，如LLM模型、沙箱环境、浏览器和搜索引擎，用于支撑复杂的任务规划与执行。该流程通过异步生成事件的方式与外部交互，支持流程各种状态间的切换和恢复。文件还包含详尽的日志记录，便于跟踪计划执行的每个步骤及异常情况。"
    }
  ],
  "functions": [
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.__init__",
      "source": "    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化流程对象，接受一个 Agent 及其他关键参数，需验证子类已定义唯一的 flow_id，否则抛出 ValueError；并将 agent 等信息绑定到实例上。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步生成器接口，接收消息字符串作为输入，返回 AsyncGenerator[AgentEvent, None]，由具体实现产出执行过程中的事件流。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "检查当前 Flow 是否处于闲置状态，返回布尔值，供调度器判断是否可切换到其他流程。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回该 Flow 的唯一标识符 flow_id。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回该 Flow 的描述信息，若未显式描述则给出默认描述。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构造 BaseSubFlow，注入 llm、sandbox、browser、search_engine、audio_llm、image_llm、video_llm、reason_llm、task_type 等依赖对象，并保存为实例属性，便于后续运行使用。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.run",
      "source": "    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "抽象异步生成器，接收 parent_plan、parent_step、parent_memory、task_type，执行对应子规划器并产出 AgentEvent 序列，包含执行过程、工具使用与最终结果的报告。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "检查子流程是否处于闲置状态，返回布尔值。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回子流程的唯一 flow_id。"
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "类方法，返回子流程的描述信息，若未显式描述则返回默认描述。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "该构造函数接收 llm、sandbox、browser 等外部依赖以及可选任务类型，初始化日志、内存及父类，创建 SubPlannerAgent 与 ExecutionAgent，并对创建过程进行错误处理与日志记录。返回值为 None。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "该异步生成器入口，输入为父计划、父步骤、父记忆与任务类型，负责从父步骤描述出发创建子计划、执行子计划的步骤、总结与更新，并持续产出各类 AgentEvent 以驱动上层处理；过程中会动态更新系统提示词和内存、处理阶段状态转换、并在完成时输出最终的 PlanCompletedEvent 与 DoneEvent。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "返回当前状态是否为 Idle，判断流程是否处于空闲状态。"
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "将当前子计划的结构、步骤及状态以日志形式输出，便于调试与追踪。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构造函数，初始化日志、内存与父类，创建 SubPlannerAgent 与 ExecutionAgent，并对异常进行日志记录与抛出。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步生成器入口，依据父计划信息协调子规划与执行，更新提示词、创建子计划、执行步骤、更新计划、生成最终报告并输出完成事件。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前状态是否为 IDLE，用于控制流程是否进入下一阶段。"
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "辅助方法，将当前计划的详细信息输出到日志，便于调试与监控。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化搜索流对象，设置知识库、最大迭代次数、已处理的 gap 集合及初始状态，并准备必要的外部依赖引用（如 llm、sandbox、browser 等）。用于后续 run 调度与执行器的组装。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.is_idle",
      "source": "    def is_idle(self):\n        return self.status == \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前状态是否为 idle，作为流程是否已就绪的简易状态检查。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.run",
      "source": "    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "以异步生成器形式执行整个多步 gap 处理流程，兼容多种参数风格，内部构建 Memory/Plan/Step 等对象并创建 ExecutionAgent，循环执行 gap 的检索、评分、分析与反射，最终生成并返回最终答案，同时产生活跃的事件流。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.select_scoring_mode",
      "source": "    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "根据全局问题通过 llm 判断需要使用的评估类型列表，输出 EvalType 字符串列表，作为后续打分的配置输入。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_gaps",
      "source": "    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "调用 llm 根据全局问题生成若干 gap（以文本形式表示），返回 Gap 列表，若解析失败则回退到以全局问题为 gap 的兜底。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.search_gap",
      "source": "    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "根据当前 gap 构造带有知识库上下文的执行计划并通过执行器执行，返回包含 gap 与检索结果的字典；若执行完成则返回最终结果清单。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.score_gap",
      "source": "    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "针对单个 gap 的检索结果，逐个评估类型执行提示并通过 llm 判断是否通过，返回是否满足及理由文本。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._get_prompts",
      "source": "    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "根据评估类型构造系统提示与用户提示的模板对，用于 score_gap 的对话推理。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.analyze_gap",
      "source": "    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "当某个 gap 的检索结果未通过时，借助 llm 对失败原因进行简要分析并返回分析文本。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap",
      "source": "    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "给定 gap 与失败原因，利用 llm 生成一个新的更精确的子问题（gap）或改进的检索表达，返回新 gap 列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap_batch",
      "source": "    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "对一轮中多条失败 gap 的情况进行批量反射，汇总生成新的 gap 列表，提升后续检索的覆盖性。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._filter_and_update_gaps",
      "source": "    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "对 gap 列表进行去重并更新已处理集合，返回尚未处理的新 gap 列表。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.format_search_result",
      "source": "    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "将复杂的检索结果（字符串/字典/列表等）规范化为可读文本，优先展示关键字段与结果文本。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_final_answer",
      "source": "    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "将知识库内容与全局问题综合，调用 llm 生成最终答案，并指示是否需要更多信息（need_more）。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.summarize_execution",
      "source": "    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "生成流程执行摘要的异步产出，方便后续汇报。"
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_report",
      "source": "    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "生成流程最终报告的异步产出，方便后续审阅与展示。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构造函数，连接 SubPlannerAgent 与 ExecutionAgent，初始化内存与日志，创建并配置系统提示词，捕获并记录初始化过程中的异常并抛出。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步生成器，驱动子计划的整个工作流（规划、执行、更新、报告、完成），在过程中更新系统提示词、产生与转发事件并累积执行结果到内存；依赖子代理输出的事件并与执行代理交互。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "简单判断当前状态是否为 IDLE，作为流程是否可重新开始的判断入口。"
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "日志化输出当前计划及其步骤的辅助方法，便于诊断与调试。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 FlowFactory，创建内部流类型字典并注册默认的主流程类型。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册计划/行动与简单聊天等默认主流程，并延迟导入 SuperFlow 以避免循环导入。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册新的主流程类，校验子类关系与 flow_id，若重复则覆盖并记录日志。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.create_flow",
      "source": "    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据 flow_id 与多种依赖参数创建相应的主流程实例，并返回 BaseFlow 对象，遇错时抛出异常并记录日志。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "返回所有已注册主流程的简要信息列表（flow_id、name、description）。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "判断指定 flow_id 是否已注册。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "获取指定 flow_id 对应的主流程类。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 SubFlowFactory，设置专用日志记录器并注册默认的子流程类型。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册默认的子流程类型 DefaultFlow、SearchFlow、CodeFlow。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "注册新的子流程类，校验子类及 flow_id，重复覆盖时记录日志。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.create_flow",
      "source": "    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据任务类型创建相应的子流程实例，包含详细的调试日志、流类型重定向逻辑与参数传递，遇错时记录并抛出异常。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "返回所有已注册的子流程类型信息（flow_id、name、description）。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows_enum",
      "source": "    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "基于可用子流程生成并返回一个新的 Enum 类型，用于表示子流程枚举。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "判断指定 flow_id 是否在已注册的子流程中。"
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "获取指定 flow_id 对应的子流程类。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构造函数，初始化 SimpleChatFlow 的依赖项、状态以及父类。输入包含 Agent、多种 LLM 接口、Sandbox、Browser、可选的 SearchEngine 等参数，并通过 super().__init__(agent, **kwargs) 初始化父类，设置初始闲置状态并记录日志。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步生成器方法，执行简单聊天流程。输入为 message 字符串，输出为 AsyncGenerator[AgentEvent, None]，在流程中构建提示、调用 llm.ask 获取回复并通过 MessageEvent 输出，遇错时输出错误信息并继续，最终切换回闲置状态并发出 DoneEvent。内部依赖 self.llm.ask，并对异常进行日志记录。"
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "返回当前流程的闲置状态（布尔值）。无输入参数，直接返回 self._is_idle 的值。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化 SuperFlow，设置依赖组件（llm、sandbox、browser、search_engine、音视频 LLM 等）、创建 PlannerAgent、ReportAgent、NotifyAgent、记忆对象，以及子流程工厂与状态追踪结构，配置专用日志器并记录初始化信息。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._determine_task_type",
      "source": "    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "根据步骤描述内容推断任务类型，优先匹配代码、搜索、推理、文件等类别，默认返回 \"search\"。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.execute_step",
      "source": "    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "对单个步骤进行执行，基于步骤的 sub_flow_type 或描述推断任务类型，创建对应的 SubFlow 并执行，通过异步产生的事件对步骤状态进行更新并转发相关事件（如 StepStartedEvent、StepFailedEvent、StepCompletedEvent、MessageEvent、ReportEvent），遇错或暂停时进行处理并回退/返回，必要时记录错误信息。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._build_parallel_execution_groups",
      "source": "    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "构建并发执行组，将计划中的步骤按 sub_plan_step 进行分组，处理缺失字段、转换异常、顺序错乱等异常情况，并将结果保存为 deque 形式的并行组，日志记录分组信息与错误信息。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "处理用户消息的主循环，基于状态机在 IDLE、PLANNING、EXECUTING、UPDATING、REPORTING、COMPLETED 之间切换，调用 notifier 进行消息通知、planner_agent 生成计划并在得到计划后构建执行组、逐组执行步骤、在更新阶段触发计划更新、最后生成并输出最终报告，整个过程会产出和转发多种事件（如 MessageEvent、PlanCreatedEvent、PlanUpdatedEvent、PlanCompletedEvent、DoneEvent 等）。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前流程是否处于空闲状态（IDLE）。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "将当前计划的详细信息输出到日志，以便调试和追踪计划的结构与各步骤状态。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_report_to_knowledge",
      "source": "    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "将当前报告内容以知识记忆形式写入 knowledge 内存，形式为对话角色为助手的消息。"
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_step_to_knowledge",
      "source": "    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "将当前步骤描述作为知识记忆中的用户消息写入 knowledge 内存。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "初始化PlanActFlow实例，设置初始状态，创建PlannerAgent、ExecutionAgent和NotifyAgent，并配置专门日志记录器，接收多种外部依赖和代理所需的模型与资源。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "异步执行核心流程，处理用户输入消息，按状态机逻辑依次进行规划、执行、更新和报告，周期性产生活动事件，支持中断和回滚，最终完成计划并释放流程资源。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "判断当前流程状态是否为空闲状态，用于外部和内部流程控制条件判断。"
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "以结构化日志形式打印计划详情，包括计划ID、目标、每个步骤的描述、状态、结果和错误信息，辅助调试和监控。"
    }
  ],
  "classes": [
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseFlow",
      "qualname": "<module>.BaseFlow",
      "source": "class BaseFlow(ABC):\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n    \n    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n\n    @abstractmethod\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n    \n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "methods": [
        "<module>.BaseFlow.__init__",
        "<module>.BaseFlow.run",
        "<module>.BaseFlow.is_idle",
        "<module>.BaseFlow.get_flow_id",
        "<module>.BaseFlow.get_description"
      ],
      "description": "流程体系中的核心抽象基类，强制实现唯一 flow_id、异步运行入口和闲置状态判定，提供获取流描述的通用方法；与 BaseSubFlow 协同支撑可扩展的流程体系。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/base.py",
      "name": "BaseSubFlow",
      "qualname": "<module>.BaseSubFlow",
      "source": "class BaseSubFlow(ABC):\n    \"\"\"\n    子规划器流程的基础接口类\n    定义了子规划器流程必须实现的核心方法\n    \"\"\"\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n\n    # 初始化SubFlow可用的基础设施\n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n\n    @abstractmethod\n    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n\n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "methods": [
        "<module>.BaseSubFlow.__init__",
        "<module>.BaseSubFlow.run",
        "<module>.BaseSubFlow.is_idle",
        "<module>.BaseSubFlow.get_flow_id",
        "<module>.BaseSubFlow.get_description"
      ],
      "description": "子规划器流程的基础接口，提供对 LLM 与多种辅助工具的注入能力、执行单步计划的异步入口以及闲置与描述方法，确保子流程能在父计划/记忆上下执行并输出 AgentEvent 流。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "定义子计划流的状态机，包含 idle、planning、executing、completed、updating、reporting 等状态，用于控制流程走向与行为分支。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/sub_planner_flow.py",
      "name": "SubPlannerFlow",
      "qualname": "<module>.SubPlannerFlow",
      "source": "class SubPlannerFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"general\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.SubPlannerFlow.__init__",
        "<module>.SubPlannerFlow.run",
        "<module>.SubPlannerFlow.is_idle",
        "<module>.SubPlannerFlow._show_plan"
      ],
      "description": "负责整体子计划流的生命周期管理，包括初始化外部依赖、创建子规划与执行代理、维护流程状态、以及通过异步事件流与上层组件协作完成从创建到执行再到报告的完整流程。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "定义子流程的状态机枚举，包含 idle、planning、executing、completed、updating、reporting 等状态，用于驱动 run 的流程控制。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/default_flow.py",
      "name": "DefaultFlow",
      "qualname": "<module>.DefaultFlow",
      "source": "class DefaultFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"default\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.DefaultFlow.__init__",
        "<module>.DefaultFlow.run",
        "<module>.DefaultFlow.is_idle",
        "<module>.DefaultFlow._show_plan"
      ],
      "description": "实现默认子流程的协调逻辑，负责初始化子规划与执行代理、运行流程的状态机、处理父流程输入输出并生成最终报告与完成事件。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/search_flow.py",
      "name": "SearchFlow",
      "qualname": "<module>.SearchFlow",
      "source": "class SearchFlow(BaseSubFlow):\n    flow_id = \"search\"\n    description = \"多步gap反射搜索流程\"\n\n    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n\n    def is_idle(self):\n        return self.status == \"idle\"\n\n    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n\n    # ========== 以下为各模块实现 ==========\n\n    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n\n    #生成gap\n    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n\n    #由run方法中串行调用，利用executor搜索单个gap\n    # async def search_gap(self, gap: str) -> dict:\n    #     #print(\"search_gap 搜索问题 运行到了\")\n    #     # 1. 构造一个step\n    #     # step = Step(\n    #     #     id=\"search_gap\",\n    #     #     description=f\"请使用搜索工具检索以下内容：{gap}\",\n    #     #     status=ExecutionStatus.PENDING\n    #     # )\n    #     step = Step(\n    #         id=\"search_gap\",\n    #         description=(\n    #             f\"You have access to all available tools, including search engines, web browsers, code execution, and multimedia analysis.\"\n    #             f\"\\nPlease select the most appropriate tool(s) to solve the following sub-question. \"\n    #             f\"Actively call the needed tools, integrate their output, and provide a clear answer.\"\n    #             f\"If you encounter a question that needs reading files(pdf/word/txt) to obtain the answer, you should try to download the file from the internet for more accurate answers.\"\n    #             f\"If you are required to find answers from related essays, articles or books, you should download them and check the file by reading them locally.\"\n    #             f\"In most conditions, searching information about content of an article/book/essay is not a good idea, not much information can be found online, download and read the file if needed.\"\n    #             f\"\\nSub-question: {gap}\"\n    #         ),\n    #         status=ExecutionStatus.PENDING\n    #     )\n    #\n    #     # 2. 构造一个最小Plan\n    #     plan = Plan(\n    #         id=\"search_gap_plan\",\n    #         title=\"Search Gap Task\",\n    #         goal=gap,\n    #         steps=[step]\n    #     )\n    #     all_messages = []\n    #     final_result = None\n    #     final_error = None\n    #\n    #     # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n    #     async for event in self.executor.execute_step(plan, step, gap):\n    #         if hasattr(event, \"message\"):\n    #             all_messages.append(event.message)\n    #         if isinstance(event, StepCompletedEvent):\n    #             # 把最终 result 也放到 messages 最后\n    #             all_messages.append(event.step.result)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #         elif isinstance(event, StepFailedEvent):\n    #             # 错误处理\n    #             all_messages.append(event.step.error)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #\n    #\n    #     # 4. fallback，兜底\n    #     #print(\"如果gap no result found，以下会被打印：\")\n    #     #print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n    #     # return {\"gap\": gap, \"error\": \"No result\"}\n    #     all_messages.append(\"No result\")\n    #     return {\"gap\": gap, \"result\": all_messages}\n\n    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n\n\n    #为gap执行结果打分，打分为boolean值\n    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n\n\n    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n\n\n    #analyze分析本次gap执行错误的原因\n    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n\n    #reflect负责根据失败原因提供新的gap\n    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n\n    #reflect batch负责一整轮gap结束后的反思以及提供新gap，实现一个简单的没有plan的递进\n    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n\n\n    #为避免出现过于相似或者重复的gap，generate后使用filter去重\n    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n\n    #此处规范化result，保证知识库内信息不为空\n    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n\n    #最后一步，生成最终报告\n    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n\n    # ========== 可选 summary/report 接口 ==========\n    # 两个方法视情况使用，目前在代码中并未用到\n\n    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n        # 可以输出 self.knowledge 等\n\n    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "methods": [
        "<module>.SearchFlow.__init__",
        "<module>.SearchFlow.is_idle",
        "<module>.SearchFlow.run",
        "<module>.SearchFlow.select_scoring_mode",
        "<module>.SearchFlow.generate_gaps",
        "<module>.SearchFlow.search_gap",
        "<module>.SearchFlow.score_gap",
        "<module>.SearchFlow._get_prompts",
        "<module>.SearchFlow.analyze_gap",
        "<module>.SearchFlow.reflect_gap",
        "<module>.SearchFlow.reflect_gap_batch",
        "<module>.SearchFlow._filter_and_update_gaps",
        "<module>.SearchFlow.format_search_result",
        "<module>.SearchFlow.generate_final_answer",
        "<module>.SearchFlow.summarize_execution",
        "<module>.SearchFlow.generate_report"
      ],
      "description": "负责实现基于多步 gap 的反射搜索工作流的核心类。它维护知识库、gap 处理状态、迭代逻辑与执行代理，负责 gap 的生成、检索、打分、分析、反射及最终答案的整合输出，并通过事件流向外部系统汇报进展与结果。该类的关键方法包括 run、generate_gaps、search_gap、score_gap、reflect_gap、generate_final_answer 等，以及辅助的格式化与提示生成功能。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "枚举，表示 CodeFlow 的生命周期状态（idle、planning、executing、completed、updating、reporting）。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/code_flow.py",
      "name": "CodeFlow",
      "qualname": "<module>.CodeFlow",
      "source": "class CodeFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"code\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.CodeFlow.__init__",
        "<module>.CodeFlow.run",
        "<module>.CodeFlow.is_idle",
        "<module>.CodeFlow._show_plan"
      ],
      "description": "负责整个子计划的编排与协作，管理 SubPlannerAgent 与 ExecutionAgent，负责从创建计划到执行、更新、汇报的完整流程，并提供用于事件流的 run() 和用于诊断的 _show_plan。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "FlowFactory",
      "qualname": "<module>.FlowFactory",
      "source": "class FlowFactory:\n    \"\"\"Flow工厂类,负责管理和创建不同类型的flow\"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n    \n    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n    \n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.FlowFactory.__init__",
        "<module>.FlowFactory._register_default_flows",
        "<module>.FlowFactory.register_flow",
        "<module>.FlowFactory.create_flow",
        "<module>.FlowFactory.get_available_flows",
        "<module>.FlowFactory.has_flow",
        "<module>.FlowFactory.get_flow_class"
      ],
      "description": "FlowFactory 类的核心实现，负责注册、创建及管理主流程类型，以及提供可用流程信息的查询能力。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    CODE = \"code\"\n    REASONING = \"reasoning\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "SubFlowFactory 用到的子流程类型枚举，用于描述和区分不同子流程任务类型的标识。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/factory.py",
      "name": "SubFlowFactory",
      "qualname": "<module>.SubFlowFactory",
      "source": "class SubFlowFactory:\n    \"\"\"\n    子流程工厂类\n    负责创建和管理所有子流程实例\n    \"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n    \n    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n\n    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n\n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.SubFlowFactory.__init__",
        "<module>.SubFlowFactory._register_default_flows",
        "<module>.SubFlowFactory.register_flow",
        "<module>.SubFlowFactory.create_flow",
        "<module>.SubFlowFactory.get_available_flows",
        "<module>.SubFlowFactory.get_available_flows_enum",
        "<module>.SubFlowFactory.has_flow",
        "<module>.SubFlowFactory.get_flow_class"
      ],
      "description": "SubFlowFactory 类的核心实现，负责注册、创建和管理子流程实例，以及提供子流程信息查询与枚举生成功能。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/simple_chat.py",
      "name": "SimpleChatFlow",
      "qualname": "<module>.SimpleChatFlow",
      "source": "class SimpleChatFlow(BaseFlow):\n    \"\"\"简单聊天流程：直接与LLM对话，不进行计划和执行\"\"\"\n    \n    # 定义flow的唯一标识符\n    flow_id = \"simple_chat\"\n    description = \"简单聊天流程：直接与LLM对话，适用于简单的问答场景\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n    \n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n    \n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "methods": [
        "<module>.SimpleChatFlow.__init__",
        "<module>.SimpleChatFlow.run",
        "<module>.SimpleChatFlow.is_idle"
      ],
      "description": "一个简单聊天流程实现，直接将用户问题发送给 LLM 获取回复，未包含计划与执行阶段，提供基本的对话能力。核心职责是维护对话所需的依赖（LLM、音/图/视频能力与外部服务的占位接口），通过 run 方法输出 MessageEvent 与 DoneEvent 形成事件流，与 Agent 进行交互。主要交互对象包括 Agent、LLM（及其子接口）、Sandbox、Browser、SearchEngine，以及通过 Logger 进行运行时追踪。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "FlowStatus",
      "qualname": "<module>.FlowStatus",
      "source": "class FlowStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "定义了流程的六种状态（idle / planning / executing / completed / updating / reporting），用于在 SuperFlow 中进行状态机驱动和日志记录。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/super_flow.py",
      "name": "SuperFlow",
      "qualname": "<module>.SuperFlow",
      "source": "class SuperFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"TreeFLow\"\n    description = \"a flow that uses multiple planners to handle complex tasks\"\n\n    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n\n\n    @staticmethod\n    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n\n\n    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n\n\n    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n\n    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n\n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n\n    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n\n    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "methods": [
        "<module>.SuperFlow.__init__",
        "<module>.SuperFlow._determine_task_type",
        "<module>.SuperFlow.execute_step",
        "<module>.SuperFlow._build_parallel_execution_groups",
        "<module>.SuperFlow.run",
        "<module>.SuperFlow.is_idle",
        "<module>.SuperFlow._show_plan",
        "<module>.SuperFlow.add_report_to_knowledge",
        "<module>.SuperFlow.add_step_to_knowledge"
      ],
      "description": "核心协调器类，负责整合外部工具与内部组件，管理 PlannerAgent、ReportAgent、NotifyAgent、sub_flow_factory、内存与知识库，以及并发执行的子流程；提供从用户消息到计划生成、步骤执行、计划更新到最终报告的完整流程控制接口，并通过事件驱动与其他系统组件交互。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "定义代理运行的多个离散状态枚举，如空闲、规划中、执行中、更新中和完成，作为流程状态机的状态标识。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    MESSAGE = \"message\"\n    SHELL = \"shell\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "定义子规划器的类别枚举，支持消息、Shell、搜索和文件类型的子规划器，用于细粒度执行策略分类。"
    },
    {
      "file": "/home/yf/Workspace/coding_agent/backend/app/domain/services/rag/sample_workspace/flows/plan_act.py",
      "name": "PlanActFlow",
      "qualname": "<module>.PlanActFlow",
      "source": "class PlanActFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"plan_act\"\n    description = \"计划-执行流程：先创建计划，然后逐步执行，支持动态更新计划\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.PlanActFlow.__init__",
        "<module>.PlanActFlow.run",
        "<module>.PlanActFlow.is_idle",
        "<module>.PlanActFlow._show_plan"
      ],
      "description": "实现计划-执行一体化流程管理的核心类，封装了从消息接收、计划创建、步骤执行、计划更新到最终报告的全生命周期管理，协调各代理对象和外部资源，管理状态转换及事件流。"
    }
  ]
}