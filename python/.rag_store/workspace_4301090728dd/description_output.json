{
  "files": [
    {
      "file": "flows/base.py",
      "description": "BaseFlow and BaseSubFlow abstractions for flow execution and sub-planning The file defines two abstract base classes that standardize how flows and sub-flows are implemented in the system. It enforces that every concrete flow provides a unique flow_id and common lifecycle methods (run and is_idle), and exposes helper methods to query flow identifiers and descriptions. BaseFlow manages an Agent dependency and validates configuration at initialization, while BaseSubFlow encapsulates various external interfaces (LLMs, sandbox, browser, search) and memory of a planning step to be used by concrete sub-flows. Together, they establish the collaboration surface between high-level flows, sub-flows, and the external tools they leverage."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "description": "The SubPlannerFlow module defines a specialized flow that coordinates the creation and execution of sub-plans within a larger planning system. It initializes a dedicated logger, maintains an internal status tracker using AgentStatus, and wires together a SubPlannerAgent and an ExecutionAgent with various LLMs and external services (Sandbox, Browser, optional SearchEngine, and optional multimodal LLMs). The flow interacts with a Memory store and a PromptManager to manage dynamic prompts and state, updating system prompts as the sub-plan progresses. Its run method orchestrates the end-to-end lifecycle: from planning to executing steps, handling updates, summarization, and reporting, while emitting a stream of AgentEvent-derived messages to the caller. It collaborates with a parent planner by consuming parent plan/step/memory and a task type, performing planning, execution, and sub-plan updates through its agent components."
    },
    {
      "file": "flows/default_flow.py",
      "description": "File-level summary This module defines a default sub-flow that orchestrates sub-planning and execution within a larger workflow. It introduces an AgentStatus enum to track the lifecycle states of the flow (idle, planning, executing, updating, reporting, completed). The DefaultFlow class extends a base sub-flow and coordinates two internal agents: a SubPlannerAgent for generating a sub-plan and an ExecutionAgent for carrying out the plan’s steps. It wires together LLMs, sandbox, browser, optional search, and various multimodal helpers, along with memory and prompt management to adapt prompts dynamically based on context. Extensive logging is used through a specialized sub-planner logger to trace initialization, plan creation, step execution, plan updates, and final reporting. The run method implements an end-to-end lifecycle: initialize agents, create a sub-plan, execute steps, summarize and update the sub-plan, and emit final events such as a plan completion or a report, enabling integration with the parent planning flow."
    },
    {
      "file": "flows/search_flow.py",
      "description": "File-level summary - This file defines a SearchFlow class that orchestrates a multi-step, gap-based reflection search workflow. It leverages a large language model (LLM) and an execution engine to iteratively generate, search, evaluate, reflect on, and refine gaps until a final answer can be produced. It maintains an in-memory knowledge base of solved gaps and their summaries, and supports serial execution (as opposed to parallel) for gap processing. The flow integrates with memory, plan/step models, and executor events, and heavily relies on structured prompts to guide evaluation, gap generation, and final answer synthesis. Several helper methods format search results, manage gap queues, and generate final outputs."
    },
    {
      "file": "flows/code_flow.py",
      "description": "CodeFlow orchestrates a sub-plan lifecycle: it initializes specialized agents (a sub-planner and an execution agent), creates a sub-plan from a parent plan/step, executes the sub-plan step-by-step, dynamically updates the sub-plan based on execution outcomes, and finally reports completion. It relies on a rich set of domain models (events, plans, steps) and external services (LLMs, sandbox, browser, search) plus a memory and prompt-management subsystem to maintain and adjust the planning and execution context. The file defines an AgentStatus enum to track the sub-flow's lifecycle and a CodeFlow class that coordinates planning, execution, updating, and reporting, emitting various AgentEvents to its caller. It integrates detailed logging for observability and uses asynchronous iteration to stream events from sub-components. The CodeFlow interacts closely with SubPlannerAgent and ExecutionAgent, updating prompts and memory as the flow progresses and handling errors with robust logging and fallbacks."
    },
    {
      "file": "flows/factory.py",
      "description": "FlowFactory and SubFlowFactory implement a flexible factory system for creating both high-level flows and sub-flows. The file registers default flow types, validates and instantiates flow classes with rich dependencies (agent, LLMs, sandbox, browser, search engine, etc.), and exposes APIs to query available flows and check existence. It defines a global FlowFactory instance and a SubFlowFactory with a separate SubPlannerType enum to map high-level task types to specific sub-flows. The code relies on multiple flow implementations (PlanActFlow, SimpleChatFlow, SuperFlow, DefaultFlow, SearchFlow, CodeFlow) and integrates with domain models (Agent) and external services (LLM, Sandbox, Browser, SearchEngine). Logging is extensively used to trace registration, creation, and error conditions, including a dedicated logger for sub-flow operations."
    },
    {
      "file": "flows/simple_chat.py",
      "description": "This file defines SimpleChatFlow, a concrete implementation of a chat flow that directly talks to a language model (LLM) without planning or executing extra steps. It wires together various external services and models, including multiple specialized LLM interfaces (LLM, AudioLLM, ImageLLM, VideoLLM, ReasonLLM), a Sandbox, a Browser, and an optional SearchEngine, and it interacts with domain models such as Agent and domain events like AgentEvent, MessageEvent, and DoneEvent. The flow maintains an internal idle state (_is_idle) to indicate availability and uses asynchronous generation to emit events as the conversation progresses. The run method constructs a simple prompt, queries the LLM, and yields a MessageEvent with the LLM response, handling errors by emitting an error message and finally yielding a DoneEvent. Logging is used throughout to trace creation, start, success/failure, and completion of interactions with the agent."
    },
    {
      "file": "flows/super_flow.py",
      "description": "File-level summary The file implements a high-level orchestration flow named SuperFlow that coordinates multiple sub-flows to tackle complex tasks. It defines a FlowStatus enum to represent the lifecycle states (idle, planning, executing, updating, reporting, completed) and a SuperFlow class that manages planning, execution, updating, and final reporting phases. It collaborates with various agents (PlannerAgent, ReportAgent, NotifyAgent) and external tools (LLMs, Sandbox, Browser, SearchEngine) and uses a sub_flow_factory to spawn specialized sub-flows based on the task type. It maintains separate memories for planning and knowledge, and tracks sub-flow execution history and active sub-flows. The run loop processes user messages, builds execution plans, executes steps (potentially in parallel groups), updates plans based on results, and emits events such as PlanCreatedEvent, StepStartedEvent, StepCompletedEvent, StepFailedEvent, and PlanUpdatedEvent to inform collaborators."
    },
    {
      "file": "flows/plan_act.py",
      "description": "PlanActFlow orchestrates a plan-then-act loop by coordinating planner, executor, and notifier sub-agents to transform user input into a concrete plan and iteratively execute and update it. It defines a small FSM of statuses (idle, planning, executing, updating, reporting, completed) to drive the flow, and relies on a variety of domain events (PlanCreatedEvent, PlanUpdatedEvent, ToolCallingEvent, etc.) to communicate progress. The module imports extensive domain models, memory, and external services (LLMs, Sandbox, Browser, SearchEngine) and uses a specialized plan-act logger alongside the standard logger for structured logging. It constructs PlannerAgent, ExecutionAgent, and NotifyAgent instances bound to the provided agent memories and external resources, enabling end-to-end orchestration from plan creation to final reporting. It also provides a helper for inspecting plans and a simple idle check to drive restarts, and it yields events to consumers as the flow progresses."
    },
    {
      "file": "__init__.py",
      "description": "This file serves as a package initializer, re-exporting selected classes from its submodules for convenient imports. It imports SoftmaxRegression from softmax_regression and TwoLayerNet from two_layer_nn, exposing them at the package level. The code relies on relative imports within a package that contains softmax_regression.py and two_layer_nn.py. There is an extraneous trailing token \"hello\" which would cause a syntax error when importing. The file itself does not define functions or classes beyond these imports; its role is to provide a simple façade to the underlying implementations."
    },
    {
      "file": "hello.py",
      "description": "The Python module hello.py is a minimal, single-file component that currently defines no executable logic. It does not declare imports, functions, classes, or variables, making it effectively an empty module. The visible content shows a single token \"hello,\" suggesting the file is a placeholder or an incomplete stub rather than a functional script. As there are no dependencies, this module does not interact with other components or libraries. With no API surface or runtime behavior, the file functions as a starting scaffold for future development."
    }
  ],
  "functions": [
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.__init__",
      "source": "    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize a flow with an Agent; validates that flow_id is defined on the concrete subclass and stores the agent."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract coroutine that should yield AgentEvent objects as the flow processes the given message."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract method to indicate whether the flow is currently idle."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return the class-level flow_id for this flow."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return a descriptive string for the flow, using a description attribute if present or a default based on flow_id."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize a sub-flow with core infrastructure (LLMs, sandbox, browser, search engine, media LLMs) and an optional task_type; stores all provided components on the instance."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.run",
      "source": "    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract coroutine to execute a single step of a parent plan, producing AgentEvent objects via a generated sequence."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n",
      "calls": [],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Abstract method to indicate whether the sub-flow is currently idle."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_flow_id",
      "source": "    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return the class-level flow_id for this sub-flow."
    },
    {
      "file": "flows/base.py",
      "qualname": "flows.base.BaseSubFlow.get_description",
      "source": "    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "calls": [],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Return a descriptive string for the sub-flow, using a description attribute if present or a default based on flow_id."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the sub-planner flow by setting up a logger, preparing memory, invoking the base class constructor, and creating SubPlannerAgent and ExecutionAgent instances with the provided dependencies; also sets initial status to IDLE and plan to None, and logs initialization details."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronously orchestrates the sub-plan lifecycle for a given parent plan/step/memory; updates system prompts, creates and executes the sub-plan, handles various events (PlanCreatedEvent, ToolCallingEvent, ToolCalledEvent, MessageEvent, PlanUpdatedEvent, PauseEvent, ReportEvent, PlanCompletedEvent, DoneEvent), and yields them to the caller while managing internal state transitions."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the current status is IDLE, indicating if the flow is ready to start a new sub-plan."
    },
    {
      "file": "flows/sub_planner_flow.py",
      "qualname": "flows.sub_planner_flow.SubPlannerFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs the contents of a Plan object, including IDs, goals, and details of each step (description, status, result, error) for debugging purposes."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the default sub-flow by creating a specialized sub-planner logger, setting up memory for execution results, invoking the base class constructor with provided components, and constructing SubPlannerAgent and ExecutionAgent instances. Throws on failures to create internal agents to ensure the flow starts in a consistent state."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Orchestrates the end-to-end sub-flow lifecycle as an asynchronous generator. It fixes the current parent plan/step, updates system prompts with parent memory, creates a sub-plan from the parent step description, then iterates through planning, executing, updating, and reporting phases, yielding final PlanCompletedEvent or ReportEvent, and handling errors gracefully without breaking the entire flow."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the internal status is IDLE, indicating readiness to start a new sub-flow."
    },
    {
      "file": "flows/default_flow.py",
      "qualname": "flows.default_flow.DefaultFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs a structured summary of a given Plan’s ID, goal, steps, and each step’s metadata for debugging and traceability."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize the SearchFlow with LLM, sandbox, browser, and optional tools; set up knowledge storage, iteration limits, processed gap tracking, and idle status, preparing the executor (commented out in this version)."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.is_idle",
      "source": "    def is_idle(self):\n        return self.status == \"idle\"\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Return True when the internal status is \"idle\", indicating the flow is not actively processing."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.run",
      "source": "    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Entry point asynchronous generator that handles both legacy and new parameter styles, sets up memory and plan/step context, instantiates an ExecutionAgent, conducts scoring mode selection, gap generation, iterative gap search, result formatting and scoring, reflection for failed gaps, and final answer generation, yielding various AgentEvent objects along the way."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.select_scoring_mode",
      "source": "    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Determine applicable evaluation modes for the global question by querying the LLM with a prompt, parse the JSON response to derive a list of eval types, and return that list."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_gaps",
      "source": "    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Generate candidate gaps from the global question by prompting the LLM, parse the response as a set of gap expressions, and return the list of gaps (falling back to the global question on failure)."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.search_gap",
      "source": "    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Search or compute results for a single gap by injecting the current knowledge base into a specialized prompt, building a Plan/Step for the executor, running the executor, and returning a dict with the gap and its associated results (or a fallback No result message)."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.score_gap",
      "source": "    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Assess whether a gap’s result satisfies the given eval_types by querying the LLM with type-specific prompts, aggregating pass/fail outcomes and reasoning, and returning a boolean score with an aggregated reason string."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._get_prompts",
      "source": "    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Build system/user prompt pairs for a given eval_type (e.g., definitive, freshness, completeness, plurality, basic, file, strict) using the prompts module, or raise an error for unknown types."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.analyze_gap",
      "source": "    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Analyze why a gap’s result failed by constructing a diagnostic prompt that includes the gap, the searched content, and the reason, then querying the LLM and returning its content as the analysis."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap",
      "source": "    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "Generate new gaps (sub-questions or refined queries) by asking the LLM to analyze the gap and its failure reason, then parse the JSON response to extract new gap expressions and return them as a list."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.reflect_gap_batch",
      "source": "    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Perform batch reflection on multiple failed gaps by feeding a compiled prompt containing all gaps, failure reasons, and execution outputs to the LLM, then parse and return a list of newly generated gaps."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow._filter_and_update_gaps",
      "source": "    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Deduplicate candidate gaps against a set of already processed gaps, update the processed set, and return the new, unprocessed gaps to process next."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.format_search_result",
      "source": "    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Normalize and format a search result (which may be a string, list, or dict) into a readable string, prioritizing certain fields (title, summary, content, etc.) and handling error cases gracefully."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_final_answer",
      "source": "    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution"
      ],
      "description": "Synthesize a final answer by sending the global question and the accumulated knowledge base to the LLM, expecting a JSON response that includes the answer and a need_more flag; return the answer and need_more status, with a fallback if parsing fails."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.summarize_execution",
      "source": "    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [],
      "description": "Async generator stub that yields a simple execution summary event; can be extended to include knowledge content."
    },
    {
      "file": "flows/search_flow.py",
      "qualname": "flows.search_flow.SearchFlow.generate_report",
      "source": "    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow.execute_step"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Async generator stub that yields a final report event; can be extended to include detailed knowledge items."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.__init__",
      "source": "    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize a CodeFlow instance by wiring together a SubPlannerAgent and an ExecutionAgent, setting up a task-scoped logger, memory for execution results, and storing references to LLMs, tooling, and optional services. It also configures system prompts for the sub-planner and handles initialization errors by logging and re-raising."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.run",
      "source": "    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Orchestrate the end-to-end sub-flow for a given parent plan and step, producing an AsyncGenerator of AgentEvent. It updates prompts/memory, creates the sub-plan, executes steps with the executor, optionally updates the sub-plan based on results, and eventually emits a final report or completion event while managing state transitions across PLANNING, EXECUTING, UPDATING, REPORTING, and COMPLETED."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Return whether the CodeFlow is currently idle (i.e., not actively planning or executing)."
    },
    {
      "file": "flows/code_flow.py",
      "qualname": "flows.code_flow.CodeFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Log a human-readable dump of a given Plan, including its ID, goal, and the description/status of each step for debugging."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the FlowFactory, creating the internal registry and registering the default flow types."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Registers PlanActFlow and SimpleChatFlow, performs a lazy import of SuperFlow to avoid circular imports, and logs registration."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Validates that the provided class is a BaseFlow subclass, ensures a flow_id is defined, registers or overwrites the flow, and logs the operation."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.create_flow",
      "source": "    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Creates a flow instance by flow_id using a comprehensive set of dependencies (agent, llm, audio_llm, image_llm, video_llm, reason_llm, sandbox, browser, search_engine) and additional kwargs; logs success or errors."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Returns a list describing all registered flow types with flow_id, name, and description."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Checks whether a given flow_id is registered and returns a boolean."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.FlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Returns the registered flow class for a given flow_id or None if absent."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.__init__",
      "source": "    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the SubFlowFactory, sets up a specialized logger, and registers default sub-flow types."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory._register_default_flows",
      "source": "    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Registers DefaultFlow, SearchFlow, and CodeFlow, and logs the registrations."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.register_flow",
      "source": "    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Validates that the class is a BaseSubFlow subclass, requires a flow_id, registers or overwrites the sub-flow, and logs the operation."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.create_flow",
      "source": "    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Creates a sub-flow instance based on a task_type, performing redirect logic (e.g., file and reasoning redirect to default; search/code are treated specially); passes through llm, sandbox, browser, search_engine, optional audio/image/video/reason llms, and task_type; logs steps and errors."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows",
      "source": "    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.get_flow_class",
        "flows.factory.FlowFactory.has_flow",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.factory.SubFlowFactory.get_flow_class",
        "flows.factory.SubFlowFactory.has_flow",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "description": "Returns a list describing all registered sub-flow types with flow_id, name, and description."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_available_flows_enum",
      "source": "    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Builds and returns an Enum type representing the available sub-flow types, using the names and flow_ids from get_available_flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.has_flow",
      "source": "    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Checks whether a given flow_id is registered for sub-flows."
    },
    {
      "file": "flows/factory.py",
      "qualname": "flows.factory.SubFlowFactory.get_flow_class",
      "source": "    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "calls": [
        "flows.base.BaseFlow.get_description",
        "flows.base.BaseFlow.get_flow_id",
        "flows.base.BaseSubFlow.get_description",
        "flows.base.BaseSubFlow.get_flow_id",
        "flows.factory.FlowFactory._register_default_flows",
        "flows.factory.FlowFactory.get_available_flows",
        "flows.factory.FlowFactory.register_flow",
        "flows.factory.SubFlowFactory._register_default_flows",
        "flows.factory.SubFlowFactory.get_available_flows",
        "flows.factory.SubFlowFactory.register_flow"
      ],
      "called_by": [],
      "description": "Returns the registered sub-flow class for a given flow_id or None if absent."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initialize a SimpleChatFlow with an agent, multiple LLM interfaces (llm, audio_llm, image_llm, video_llm, reason_llm), sandbox, browser, and an optional search engine; stores dependencies, marks the flow as idle, and logs creation."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronously handle a user message by constructing a prompt, invoking the LLM, and yielding a MessageEvent with the response; on errors, yield an error MessageEvent; always yield a DoneEvent at the end and toggle idle state accordingly."
    },
    {
      "file": "flows/simple_chat.py",
      "qualname": "flows.simple_chat.SimpleChatFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseSubFlow.__init__",
        "flows.code_flow.CodeFlow.__init__",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.search_flow.SearchFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.super_flow.SuperFlow.__init__"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Return whether the flow is currently idle based on the internal _is_idle flag."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes the SuperFlow with an agent, llm, sandbox, browser, and optional components (search_engine, audio_llm, image_llm, video_llm, reason_llm). Sets up logging, memories, creates PlannerAgent, ReportAgent, and NotifyAgent, and wires a sub_flow_factory for creating sub-flows; initializes internal state for parallel execution and history tracking."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._determine_task_type",
      "source": "    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Determines a task type from a description by scanning for keywords and returning one of \"code\", \"search\", \"reasoning\", or \"file\" (defaulting to \"search\")."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.execute_step",
      "source": "    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronously executes a single Step by determining or using a specified sub_flow_type, creating a corresponding sub-flow via the sub_flow_factory, running it, and translating sub-flow events into StepStartedEvent, StepCompletedEvent, StepFailedEvent, or MessageEvent; updates the step status and handles errors or pauses."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._build_parallel_execution_groups",
      "source": "    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Builds groups of steps to execute concurrently by validating sub_plan_step values, ensuring proper order, and grouping steps with the same sub_plan_step; stores the groups in a deque for sequential processing."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "The main asynchronous loop that processes user input across states (IDLE, PLANNING, EXECUTING, UPDATING, REPORTING, COMPLETED); coordinates planning via PlannerAgent, step execution via execute_step, plan updates via PlannerAgent, and final reporting via ReportAgent; yields events to external listeners and manages state transitions."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns True if the current status is IDLE, indicating the flow is ready to accept new input."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs detailed information about the plan and its steps for debugging and observability."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_report_to_knowledge",
      "source": "    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "Adds a generated report string to the knowledge memory with the role set to assistant."
    },
    {
      "file": "flows/super_flow.py",
      "qualname": "flows.super_flow.SuperFlow.add_step_to_knowledge",
      "source": "    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseFlow.run",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.base.BaseSubFlow.run",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.FlowFactory.create_flow",
        "flows.factory.SubFlowFactory.__init__",
        "flows.factory.SubFlowFactory.create_flow",
        "flows.factory.SubFlowFactory.get_available_flows_enum",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.run",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "called_by": [],
      "description": "Adds a step description to the knowledge memory with the role set to user."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.__init__",
      "source": "    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow._filter_and_update_gaps",
        "flows.search_flow.SearchFlow._get_prompts",
        "flows.search_flow.SearchFlow.analyze_gap",
        "flows.search_flow.SearchFlow.format_search_result",
        "flows.search_flow.SearchFlow.generate_final_answer",
        "flows.search_flow.SearchFlow.generate_gaps",
        "flows.search_flow.SearchFlow.generate_report",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.search_flow.SearchFlow.reflect_gap",
        "flows.search_flow.SearchFlow.reflect_gap_batch",
        "flows.search_flow.SearchFlow.run",
        "flows.search_flow.SearchFlow.score_gap",
        "flows.search_flow.SearchFlow.search_gap",
        "flows.search_flow.SearchFlow.select_scoring_mode",
        "flows.search_flow.SearchFlow.summarize_execution",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Initializes PlanActFlow by wiring together PlannerAgent, ExecutionAgent, and NotifyAgent with the provided agent and external resources (LLMs, sandbox, browser, search engine). Sets initial state to IDLE, prepares a specialized plan_act logger, and stores references to memory sections for planning and execution."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.run",
      "source": "    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Asynchronous generator that processes an input message by moving through planning, execution, updating, and reporting stages, yielding various domain events; can interrupt and roll back ongoing sub-agents if a new message arrives, and ultimately yields PlanCompletedEvent and DoneEvent."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow.is_idle",
      "source": "    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Returns whether the flow’s status is IDLE, indicating readiness to accept a new user message."
    },
    {
      "file": "flows/plan_act.py",
      "qualname": "flows.plan_act.PlanActFlow._show_plan",
      "source": "    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "calls": [
        "flows.base.BaseFlow.__init__",
        "flows.base.BaseFlow.is_idle",
        "flows.base.BaseSubFlow.__init__",
        "flows.base.BaseSubFlow.is_idle",
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.factory.FlowFactory.__init__",
        "flows.factory.SubFlowFactory.__init__",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.search_flow.SearchFlow.__init__",
        "flows.search_flow.SearchFlow.is_idle",
        "flows.simple_chat.SimpleChatFlow.__init__",
        "flows.simple_chat.SimpleChatFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle"
      ],
      "called_by": [
        "flows.code_flow.CodeFlow.__init__",
        "flows.code_flow.CodeFlow._show_plan",
        "flows.code_flow.CodeFlow.is_idle",
        "flows.code_flow.CodeFlow.run",
        "flows.default_flow.DefaultFlow.__init__",
        "flows.default_flow.DefaultFlow._show_plan",
        "flows.default_flow.DefaultFlow.is_idle",
        "flows.default_flow.DefaultFlow.run",
        "flows.plan_act.PlanActFlow.__init__",
        "flows.plan_act.PlanActFlow._show_plan",
        "flows.plan_act.PlanActFlow.is_idle",
        "flows.plan_act.PlanActFlow.run",
        "flows.sub_planner_flow.SubPlannerFlow.__init__",
        "flows.sub_planner_flow.SubPlannerFlow._show_plan",
        "flows.sub_planner_flow.SubPlannerFlow.is_idle",
        "flows.sub_planner_flow.SubPlannerFlow.run",
        "flows.super_flow.SuperFlow.__init__",
        "flows.super_flow.SuperFlow._build_parallel_execution_groups",
        "flows.super_flow.SuperFlow._determine_task_type",
        "flows.super_flow.SuperFlow._show_plan",
        "flows.super_flow.SuperFlow.add_report_to_knowledge",
        "flows.super_flow.SuperFlow.add_step_to_knowledge",
        "flows.super_flow.SuperFlow.execute_step",
        "flows.super_flow.SuperFlow.is_idle",
        "flows.super_flow.SuperFlow.run"
      ],
      "description": "Logs a representation of a Plan’s id, goal, and per-step details for debugging and traceability."
    }
  ],
  "classes": [
    {
      "file": "/app/sample_workspace/flows/base.py",
      "name": "BaseFlow",
      "qualname": "<module>.BaseFlow",
      "source": "class BaseFlow(ABC):\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n    \n    def __init__(self, agent: Agent, **kwargs):\n        self.agent = agent\n        # 验证flow_id是否已定义\n        if self.flow_id is None:\n            raise ValueError(f\"Flow class {self.__class__.__name__} must define a flow_id\")\n\n    @abstractmethod\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行flow的主要逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n    \n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")\n",
      "methods": [
        "<module>.BaseFlow.__init__",
        "<module>.BaseFlow.run",
        "<module>.BaseFlow.is_idle",
        "<module>.BaseFlow.get_flow_id",
        "<module>.BaseFlow.get_description"
      ],
      "description": "Core abstract base for top-level flow units; enforces a unique flow_id, holds an Agent, and defines the abstract run and idle-check lifecycle along with helpers to retrieve flow identification and description."
    },
    {
      "file": "/app/sample_workspace/flows/base.py",
      "name": "BaseSubFlow",
      "qualname": "<module>.BaseSubFlow",
      "source": "class BaseSubFlow(ABC):\n    \"\"\"\n    子规划器流程的基础接口类\n    定义了子规划器流程必须实现的核心方法\n    \"\"\"\n    # 每个flow类都需要定义一个唯一的flow_id\n    flow_id: str = None\n\n    # 初始化SubFlow可用的基础设施\n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Optional[Sandbox] = None,\n        browser: Optional[Browser] = None,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Optional[Enum] = None,\n    ):\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.task_type = task_type\n\n    @abstractmethod\n    async def run(self, parent_plan: Plan, parent_step: Step, parent_memory: Memory,\n                   task_type: Enum) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子规划器并执行\n        并生成当前子规划器的最终报告\n        包括执行过程、工具使用和最终结果\n\n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n\n        Yields:\n            AgentEvent: 执行过程中的各种事件\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        pass\n\n    @classmethod\n    def get_flow_id(cls) -> str:\n        \"\"\"获取flow的唯一标识符\"\"\"\n        return cls.flow_id\n\n    @classmethod\n    def get_description(cls) -> str:\n        \"\"\"获取flow的描述信息\"\"\"\n        return getattr(cls, 'description', f\"Flow {cls.flow_id}\")",
      "methods": [
        "<module>.BaseSubFlow.__init__",
        "<module>.BaseSubFlow.run",
        "<module>.BaseSubFlow.is_idle",
        "<module>.BaseSubFlow.get_flow_id",
        "<module>.BaseSubFlow.get_description"
      ],
      "description": "Core abstract base for sub-flow planners; holds infrastructure (LLMs, sandbox, browser, search, and various specialized LLMs) and defines the abstract run and idle-check lifecycle along with helpers to retrieve flow identification and description."
    },
    {
      "file": "/app/sample_workspace/flows/sub_planner_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "An enumeration of possible lifecycle states for the sub-planner flow (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING), used to control transitions and behavior during run."
    },
    {
      "file": "/app/sample_workspace/flows/sub_planner_flow.py",
      "name": "SubPlannerFlow",
      "qualname": "<module>.SubPlannerFlow",
      "source": "class SubPlannerFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"general\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n\n        # 更新子规划器的系统提示词\n        updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n        updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n        updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n        self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = updated_system_prompt\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                self.sub_planner.system_prompt = updated_system_prompt\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        yield DoneEvent()\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.SubPlannerFlow.__init__",
        "<module>.SubPlannerFlow.run",
        "<module>.SubPlannerFlow.is_idle",
        "<module>.SubPlannerFlow._show_plan"
      ],
      "description": "The orchestrator that coordinates sub-planning and sub-execution by combining a SubPlannerAgent and an ExecutionAgent, managing prompts and memory, and emitting a sequence of AgentEvent-derived messages to drive the higher-level workflow. It handles initialization, plan creation, execution loop, plan updates, reporting, and completion, with detailed logging for observability."
    },
    {
      "file": "/app/sample_workspace/flows/default_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "An enumeration of the sub-flow lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING) used to drive the orchestration logic within DefaultFlow."
    },
    {
      "file": "/app/sample_workspace/flows/default_flow.py",
      "name": "DefaultFlow",
      "qualname": "<module>.DefaultFlow",
      "source": "class DefaultFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"default\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        #self.sub_planner_flow_logger.info(f\"=== SubPlannerFlow.__init__ 开始 ===\")\n        # self.sub_planner_flow_logger.debug(f\"接收到的参数:\")\n        # self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n        # self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n        # self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n        # self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n        # self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.debug(f\"task_type.value: {task_type.value}\")\n      #      self.sub_planner_flow_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.debug(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.debug(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.debug(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.debug(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.debug(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.debug(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        # TODO\n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.debug(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.debug(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.debug(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.debug(f\"=== 开始更新系统提示词 ===\")\n        try:\n            # 更新子规划器的系统提示词\n            updated_system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow before update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, parent_memory)\n            self.sub_planner_flow_logger.debug(f\"[DEBUG MEM] SubPlannerFlow after update mem: {updated_system_prompt}\")\n            updated_system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            if hasattr(self.sub_planner, 'system_prompt'):\n                self.sub_planner.system_prompt = updated_system_prompt\n                self.sub_planner_flow_logger.debug(f\"子规划器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"新提示词长度: {len(updated_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"子规划器没有system_prompt属性\")\n                \n            # 更新执行器的系统提示词\n            executor_system_prompt = PromptManager.insert_datetime(PromptManager.get_system_prompt_with_tools(self.executor.tools, is_executor=True))\n            if hasattr(self.executor, 'system_prompt'):\n                self.executor.system_prompt = executor_system_prompt\n                self.sub_planner_flow_logger.debug(f\"执行器系统提示词更新成功\")\n                self.sub_planner_flow_logger.debug(f\"执行器新提示词长度: {len(executor_system_prompt)}\")\n            else:\n                self.sub_planner_flow_logger.warning(f\"执行器没有system_prompt属性\")\n                \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        async for event in self.sub_planner.create_plan(message):\n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.debug(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.debug(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.debug(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.debug(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            #yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.debug(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.debug(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.debug(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.debug(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.debug(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                #    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.debug(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.debug(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    # 不转发总结事件到前端，这些是内部实现细节\n                    # yield event\n                    if isinstance(event, MessageEvent):\n                        previous_steps = event.message\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.debug(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                 #   yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                final_report = \"\"\n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        parent_step.result = event.message\n                        final_report = event.message  # 只保留最终报告\n                 #   yield event\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                # # 只发送简洁的最终报告，而不是整个执行历史\n                # yield ReportEvent(message=final_report or parent_step.result or \"子任务执行完成\")\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan, issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.DefaultFlow.__init__",
        "<module>.DefaultFlow.run",
        "<module>.DefaultFlow.is_idle",
        "<module>.DefaultFlow._show_plan"
      ],
      "description": "A sub-flow orchestrator that coordinates a SubPlannerAgent and an ExecutionAgent to create and run a sub-plan. It handles system-prompt updates, memory propagation, plan creation, step execution, plan updating, and final reporting, while emitting PlanCompletedEvent or ReportEvent to signal completion to the caller. Interacts with PromptManager for prompt updates, and relies on internal logging to trace the flow of planning and execution."
    },
    {
      "file": "/app/sample_workspace/flows/search_flow.py",
      "name": "SearchFlow",
      "qualname": "<module>.SearchFlow",
      "source": "class SearchFlow(BaseSubFlow):\n    flow_id = \"search\"\n    description = \"多步gap反射搜索流程\"\n\n    def __init__(\n        self,\n        llm,\n        sandbox,\n        browser,\n        search_engine=None,\n        audio_llm=None,\n        image_llm=None,\n        video_llm=None,\n        reason_llm=None,\n        task_type=None,\n    ):\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        self.knowledge: List[Dict[str, Any]] = []\n        self.max_iterations = 3\n\n        self.processed_gaps: set = set()\n\n        # self.executor = ExecutionAgent(\n        #     memory=Memory(),\n        #     llm=llm,\n        #     audio_llm=audio_llm,\n        #     image_llm=image_llm,\n        #     video_llm=video_llm,\n        #     reason_llm=reason_llm,\n        #     sandbox=sandbox,\n        #     browser=browser,\n        #     search_engine=search_engine\n        # )\n\n        self.status = \"idle\"\n\n    def is_idle(self):\n        return self.status == \"idle\"\n\n    async def run(\n            self,\n            parent_plan=None,\n            parent_step=None,\n            parent_memory=None,\n            task_type=None,\n            *args,\n            **kwargs\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        统一入口，兼容原有run和execute_task的参数风格。\n        支持位置参数和关键字参数。\n        \"\"\"\n        # 参数兼容处理\n        memory = parent_memory or kwargs.get('memory') or Memory()\n        plan = parent_plan or kwargs.get('plan')\n        step = parent_step or kwargs.get('step')\n        if not plan or not step:\n            # 兼容通过args传参\n            if len(args) >= 2:\n                plan, step = args[:2]\n            else:\n                raise ValueError(\"run() 必须包含 plan 和 step 两个参数\")\n\n        self.executor = ExecutionAgent(\n            memory=memory,\n            llm=self.llm,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine\n        )\n\n\n        global_question = step.description\n\n        yield MessageEvent(message=f\"初始化，目标问题：{global_question}\")\n\n        # 先选择全局评分模式列表\n        eval_types = await self.select_scoring_mode(global_question)\n\n        # gap主流程（可单独抽成私有方法，见上文）\n        gaps = await self.generate_gaps(global_question)\n        gaps = self._filter_and_update_gaps(gaps)\n        iteration = 0\n\n        #gaps=['下载文件Federico Lauria 2014年论文的全文']\n\n        # 此部分while loop针对单个gap，使用reflect_gap返回针对单个gap的反思gap\n        # while gaps and iteration < self.max_iterations:\n        #     iteration += 1\n        #     yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n        #     # search_tasks = [self.search_gap(gap) for gap in gaps]\n        #     # search_results = await asyncio.gather(*search_tasks)\n        #\n        #     # 尝试不用并发，串行\n        #     search_results = []\n        #     for gap in gaps:\n        #         result = await self.search_gap(gap)\n        #         # print(f\"[DEBUG] search_gap 返回: {result}\")\n        #         search_results.append(result)\n        #\n        #     new_gaps = []\n        #\n        #     for gap, result in zip(gaps, search_results):\n        #         summary = self.format_search_result(result)\n        #         # print(\"debug用， format后summary内容：\")\n        #         # print(summary)\n        #         score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n        #         if score:\n        #             knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n        #         else:\n        #             error_reason = await self.analyze_gap(gap, result, reason)\n        #             knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n        #                               \"iteration\": iteration}\n        #             self.knowledge.append(knowledge_item)\n        #             yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n        #             reflected_gaps = await self.reflect_gap(gap, error_reason)\n        #             yield MessageEvent(message=f\"gap [{gap}] 反射生成新gap: {reflected_gaps}\")\n        #             new_gaps.extend(reflected_gaps)\n        #     gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        # 此部分while loop针对一整轮gap，使用reflect_batch_gap返回针对一整轮gap的反思gap\n        print(f\"generate后gap内容为:{gaps}\")\n        print(type(gaps), gaps)\n        while gaps and iteration < self.max_iterations:\n            print(\"主循环开始执行\")\n            iteration += 1\n            yield MessageEvent(message=f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n            print(f\"第{iteration}轮gap处理，待处理gap: {gaps}\")\n\n            search_results = []\n            for gap in gaps:\n                #result = await self.search_gap(gap)\n                print(\"主循环中运行到executor部分\")\n                result = await self.search_gap(gap, global_question)\n                print(f'已完成对gap： {gap} 的搜索')\n                search_results.append(result)\n\n            new_gaps = []\n            failed_gaps_info = []\n\n            for gap, result in zip(gaps, search_results):\n                summary = self.format_search_result(result)\n                score, reason = await self.score_gap(gap, {\"result\": summary}, eval_types)\n                if score:\n                    print(f'gap {gap} 执行成功')\n                    knowledge_item = {\"gap\": gap, \"summary\": summary, \"raw\": result, \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 已解决，总结: {summary}\")\n                else:\n                    print(f'gap {gap} 执行失败')\n                    error_reason = await self.analyze_gap(gap, result, reason)\n                    knowledge_item = {\"gap\": gap, \"summary\": f\"失败: {error_reason}\", \"raw\": result,\n                                      \"iteration\": iteration}\n                    self.knowledge.append(knowledge_item)\n                    yield MessageEvent(message=f\"gap [{gap}] 未解决，错误分析: {error_reason}\")\n                    failed_gaps_info.append({\n                        \"gap\": gap,\n                        \"error_reason\": error_reason,\n                        \"executor_result\": result\n                    })\n\n            # 一轮gap全处理完后，统一reflect\n            if failed_gaps_info:\n                reflected_gaps = await self.reflect_gap_batch(failed_gaps_info)\n                yield MessageEvent(message=f\"本轮所有失败gap反射生成新gap: {reflected_gaps}\")\n                new_gaps.extend(reflected_gaps)\n\n            gaps = self._filter_and_update_gaps(gaps=[], new_gaps=new_gaps)\n\n        yield MessageEvent(message=\"gap处理完成，准备整合知识库生成最终答案\")\n        final_answer, need_more = await self.generate_final_answer(global_question, self.knowledge)\n        parent_step.result = final_answer\n        yield ReportEvent(message=f\"最终答案：{final_answer}\")\n        print(\"run中已yield最终答案\")\n        if need_more:\n            yield MessageEvent(message=\"LLM认为知识库仍有缺失，重新进入gap循环（本流程暂不再循环）\")\n        else:\n            yield MessageEvent(message=\"任务完成，已获得满意答案\")\n\n    # ========== 以下为各模块实现 ==========\n\n    async def select_scoring_mode(self, global_question: str)  -> List[str]:\n        \"\"\"\n        根据 global_question 的内容简单决策评分模式。\n        \"\"\"\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_SYSTEM\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt.QUESTION_EVALUATION_PROMPT_USER.format(\n                    question=global_question\n                ),\n            },\n        ]\n        # 调用 LLM\n        #print(f'select scoring mode的message{messages}')\n        response = await self.llm.ask(messages)\n        # 打印调试内容（可选）\n        #print(\"LLM returned:\", response.content)\n\n\n        eval_types = []\n        # 解析 LLM 输出\n        try:\n            analysis_result = json.loads(response.content)\n        except Exception as e:\n            print(\"LLM输出解析失败，fallback使用basic\", e)\n            eval_types.append(\"basic\") #使用basic进行兜底\n\n        if analysis_result.get(\"needsDefinitive\", True):\n            eval_types.append(\"definitive\")\n        if analysis_result.get(\"needsFreshness\", False):\n            eval_types.append(\"freshness\")\n        if analysis_result.get(\"needsPlurality\", False):\n            eval_types.append(\"plurality\")\n        if analysis_result.get(\"needsCompleteness\", False):\n            #eval_types.append(\"completeness\")\n            print()\n        if analysis_result.get(\"needsFile\", True):\n            eval_types.append(\"file\")\n\n        print(f\"[Eval] 问题需要的评估类型: {eval_types}\")\n        return eval_types\n\n    #生成gap\n    async def generate_gaps(self, global_question: str) -> list[str]:\n        #print(\"generate_gaps 生成问题 运行到了\")\n\n        current_time = datetime.now()\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_GENERATE_PROMPT_USER.format(\n            global_question=global_question,\n            current_time=datetime.now()\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return [global_question]\n\n    #由run方法中串行调用，利用executor搜索单个gap\n    # async def search_gap(self, gap: str) -> dict:\n    #     #print(\"search_gap 搜索问题 运行到了\")\n    #     # 1. 构造一个step\n    #     # step = Step(\n    #     #     id=\"search_gap\",\n    #     #     description=f\"请使用搜索工具检索以下内容：{gap}\",\n    #     #     status=ExecutionStatus.PENDING\n    #     # )\n    #     step = Step(\n    #         id=\"search_gap\",\n    #         description=(\n    #             f\"You have access to all available tools, including search engines, web browsers, code execution, and multimedia analysis.\"\n    #             f\"\\nPlease select the most appropriate tool(s) to solve the following sub-question. \"\n    #             f\"Actively call the needed tools, integrate their output, and provide a clear answer.\"\n    #             f\"If you encounter a question that needs reading files(pdf/word/txt) to obtain the answer, you should try to download the file from the internet for more accurate answers.\"\n    #             f\"If you are required to find answers from related essays, articles or books, you should download them and check the file by reading them locally.\"\n    #             f\"In most conditions, searching information about content of an article/book/essay is not a good idea, not much information can be found online, download and read the file if needed.\"\n    #             f\"\\nSub-question: {gap}\"\n    #         ),\n    #         status=ExecutionStatus.PENDING\n    #     )\n    #\n    #     # 2. 构造一个最小Plan\n    #     plan = Plan(\n    #         id=\"search_gap_plan\",\n    #         title=\"Search Gap Task\",\n    #         goal=gap,\n    #         steps=[step]\n    #     )\n    #     all_messages = []\n    #     final_result = None\n    #     final_error = None\n    #\n    #     # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n    #     async for event in self.executor.execute_step(plan, step, gap):\n    #         if hasattr(event, \"message\"):\n    #             all_messages.append(event.message)\n    #         if isinstance(event, StepCompletedEvent):\n    #             # 把最终 result 也放到 messages 最后\n    #             all_messages.append(event.step.result)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #         elif isinstance(event, StepFailedEvent):\n    #             # 错误处理\n    #             all_messages.append(event.step.error)\n    #             return {\"gap\": gap, \"result\": all_messages}\n    #\n    #\n    #     # 4. fallback，兜底\n    #     #print(\"如果gap no result found，以下会被打印：\")\n    #     #print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n    #     # return {\"gap\": gap, \"error\": \"No result\"}\n    #     all_messages.append(\"No result\")\n    #     return {\"gap\": gap, \"result\": all_messages}\n\n    async def search_gap(self, gap: str, global_question: str = None) -> dict:\n        print(\"search_gap被调用\")\n        # 1. 知识库标准化并装入prompt\n        knowledge_text = \"\"\n        if self.knowledge:\n            knowledge_text = \"\\n\".join(\n                f\"Sub-question: {item.get('gap', '')}\\nContent: {item.get('summary', '')}\"\n                for item in self.knowledge\n            )\n\n        #局域prompt存储\n        prompt_parts = []\n\n        # =知识库相关prompt\n        if knowledge_text:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"Below is the current knowledge base collected from previous sub-questions. \"\n                \"You MUST use this information to answer the current sub-question if possible. \"\n                \"If the knowledge base already contains a clear answer, you should directly summarize or reuse it. \"\n                \"Only use external tools/search if the knowledge base is insufficient.\\n\"\n                f\"{knowledge_text}\\n\"\n            )\n        else:\n            prompt_parts.append(\n                \"---- KNOWLEDGE BASE ----\\n\"\n                \"The knowledge base is currently empty. You may need to use available tools to answer the sub-question.\\n\"\n            )\n        #print(f'知识库部分：{prompt_parts}')\n\n        #关于search_flow所需的特别的executor的prompt\n        execution_prompt=prompt.EXECUTION_DESCRIPTION_PROMPT.format(\n            gap=gap\n        )\n        prompt_parts.append(execution_prompt)\n\n        #来自execution.py，专门用来向executor解释他的能力\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        system_prompt = prompt.EXECUTION_SYSTEM_PROMPT.format(\n            cur_time=current_time.isoformat()\n        )\n        prompt_parts.append(system_prompt)\n\n        full_prompt = \"\\n\".join(prompt_parts)\n\n        # 3. Compose Step with new prompt\n        step = Step(\n            id=\"search_gap\",\n            description=full_prompt,\n            status=ExecutionStatus.PENDING\n        )\n\n        #2构造一个最小Plan\n        plan = Plan(\n            id=\"search_gap_plan\",\n            title=\"Search Gap Task\",\n            goal=gap,\n            steps=[step]\n        )\n        all_messages = []\n        final_result = None\n        final_error = None\n\n        # 3. 调用executor执行，因后端executor较为标准，暂时使用，后期会针对此处使用的特定工具进行优化\n        print(\"prompt制作完成，开始调用executor\")\n        async for event in self.executor.execute_step(plan, step, gap):\n            if hasattr(event, \"message\"):\n                all_messages.append(event.message)\n                print(\"获取到了message\")\n            if isinstance(event, StepCompletedEvent):\n                # 把最终 result 也放到 messages 最后\n                all_messages.append(event.step.result)\n                print(\"获取到了StepCompletedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n            elif isinstance(event, StepFailedEvent):\n                # 错误处理\n                all_messages.append(event.step.error)\n                print(\"获取到了StepFailedEvent\")\n                return {\"gap\": gap, \"result\": all_messages}\n\n        # 4. fallback，兜底\n        print(\"如果gap no result found，以下会被打印：\")\n        # print(f\"[DEBUG][search_gap] gap: {gap} No result found.\") #test\n        # return {\"gap\": gap, \"error\": \"No result\"}\n        all_messages.append(\"No result\")\n        return {\"gap\": gap, \"result\": all_messages}\n\n\n    #为gap执行结果打分，打分为boolean值\n    async def score_gap(self, gap: str, result: dict, eval_types: list = None) -> (bool, str):\n\n        #print(\"score_gap 评价结果 运行到了\")\n        \"\"\"\n        判断搜索结果是否满足gap问题，返回(bool, summary)\n        \"\"\"\n\n        #这里改为根据eval_types选择prompt\n        #遍历eval_types，检查是否每个eval_type都通过\n        satisfied=True\n        reason=\"\"\n        for eval_type in eval_types:\n            eval_type=eval_type\n            question=gap\n            answer_action=result.get('result', '')[:1000]\n            relevant_knowledge=[\"none\"]\n            system_prompt, user_prompt = self._get_prompts(\n                eval_type, question, answer_action, relevant_knowledge\n            )\n\n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": user_prompt},\n            ]\n            #print(f'为gap评分时的message{messages}')\n            response = await self.llm.ask(messages)\n            #print(response.content)\n            # print(\"score_gap debug内容\")\n            # print(response) #test\n            try:\n                data = json.loads(response.content)\n                passed = data.get(\"pass\", False)\n                if not passed:\n                    satisfied=False\n                reason = reason+data.get(\"think\", \"\")\n            except Exception as e:\n                # 解析失败时降级为“不满足”，并输出原始内容\n                satisfied=False\n                reason=reason+f\"LLM判分输出无法解析，原始内容：{getattr(response, 'content', '')}\"\n        #print(f'satisfied: {satisfied}, reason: {reason}, gap{gap}')\n        return satisfied, reason\n\n\n    def _get_prompts(\n        self,\n        eval_type: str,\n        question: str,\n        answer_action: str,\n        knowledge: List[str],\n    ) -> tuple[str, str]:\n        \"\"\"获取评估类型的提示词模板\"\"\"\n        if eval_type == \"strict\":\n            system_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_SYSTEM.format(\n                knowledge_str=\"\\n\".join(knowledge)\n            )\n            user_prompt = prompt.REJECT_ALL_ANSWERS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"definitive\":\n            system_prompt = prompt.DEFEINITE_PROMPT_SYSTEM\n            user_prompt = prompt.DEFEINITE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"freshness\":\n            system_prompt = prompt.FRESHNESS_PROMPT_SYSTEM.format(\n                currentTime=datetime.now().isoformat()\n            )\n            user_prompt = prompt.FRESHNESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"completeness\":\n            system_prompt = prompt.COMPLETENESS_PROMPT_SYSTEM\n            user_prompt = prompt.COMPLETENESS_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"plurality\":\n            system_prompt = prompt.PLURALITY_PROMPT_SYSTEM\n            user_prompt = prompt.PLURALITY_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"basic\":\n            system_prompt = prompt.BASIC_PROMPT_SYSTEM\n            user_prompt = prompt.BASIC_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        elif eval_type == \"file\":\n            system_prompt = prompt.FILE_PROMPT_SYSTEM\n            user_prompt = prompt.FILE_PROMPT_USER.format(\n                question=question, answer=answer_action\n            )\n        else:\n            raise ValueError(f\"未知的评估类型: {eval_type}\")\n\n        return system_prompt, user_prompt\n\n\n    #analyze分析本次gap执行错误的原因\n    async def analyze_gap(self, gap: str, result: dict, reason:str) -> str:\n        #print(\"analyze_gap 分析失败原因 运行到了\")\n        \"\"\"\n        分析gap未被解决的原因，返回分析文本\n        \"\"\"\n        prompt = f\"\"\"\n    你是一个问题诊断专家。现在有一个子问题未能通过已有搜索内容得到解答，请分析原因，并用一句话简明扼要地说明。不要输出多余内容。\n\n    子问题：{gap}\n    搜索内容：{result.get('result', '')[:1000]}\n    对该子问题未成功解决的简单分析{reason}\n    未解决原因：\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'分析问题失败原因的message{messages}')\n        response = await self.llm.ask(messages)\n        # 直接返回 LLM 输出内容\n        return getattr(response, \"content\", \"\").strip()\n\n    #reflect负责根据失败原因提供新的gap\n    async def reflect_gap(self, gap: str, error_reason: str) -> list[str]:\n        \"\"\"\n        用LLM结合gap和失败原因，生成新的gap（子问题）或改进的检索表达。\n        \"\"\"\n        #print(\"运行到反射错误问题！！！！！！！！！！！！！！！！！！！！！！！！！！！！\")\n\n        current_time = datetime.now()  # 当前本地时间，类型为datetime对象\n        current_year = current_time.year  # 当前年份，整数\n        current_month = current_time.month\n\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_year,\n            currentMonth=current_month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query=gap,\n            think=\"分析用户搜索意图，生成更精确的查询\",\n            context=error_reason\n        )\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        #print(f'反射新gap的message{messages}')\n        response = await self.llm.ask(messages)\n        print(\"成功获取llm返回的新gaps，raw\")\n        print(response.content)\n        try:\n            data = json.loads(response.content)\n            queries = data.get(\"queries\", [])\n            gaps = []\n            for query in queries:\n                print(\"开始将返回内容格式化为query\")\n                if isinstance(query, dict):\n                    # 按字段顺序拼成 \"key1:value1 key2:value2 ...\"\n                    fields = [f\"{k}:{str(v)}\" for k, v in query.items() if str(v).strip()]\n                    if fields:\n                        gaps.append(\" \".join(fields))\n                        print(\"gaps已经成功append\")\n                        print(fields)\n            return gaps\n        except Exception as e:\n            print(\"解析失败:\", e)\n            return []\n\n    #reflect batch负责一整轮gap结束后的反思以及提供新gap，实现一个简单的没有plan的递进\n    async def reflect_gap_batch(self, failed_gaps_info: list[dict]) -> list[str]:\n        \"\"\"\n        批量反射：输入多组gap及分析，生成新gap列表\n        \"\"\"\n        current_time = datetime.now()\n        prompt_lines = []\n        for i, info in enumerate(failed_gaps_info, 1):\n            prompt_lines.append(\n                f\"{i}. 子问题: {info['gap']}\\n失败原因: {info['error_reason']}\\n执行器内容: {self.format_search_result(info['executor_result'])}\\n\"\n            )\n        prompt_str = \"\\n\".join(prompt_lines) #本轮子问题以及失败原因，用于生成新gap\n        system_prompt = prompt.QUERY_REWRITE_PROMPT_SYSTEM.format(\n            currentTime=current_time.isoformat(),\n            currentYear=current_time.year,\n            currentMonth=current_time.month\n        )\n        user_message = prompt.QUERY_REWRITE_PROMPT_USER.format(\n            query_group=prompt_str,\n        )\n        #user_message = f\"以下是本轮未解决的子问题、失败原因和相关内容，请针对每个子问题，结合失败原因给出更精确、可直接搜索的新子问题表达，输出如下格式JSON：\\n{{\\n  \\\"queries\\\": [\\\"新子问题1\\\", \\\"新子问题2\\\", ...]\\n}}\\n\\n{prompt_str}\"\n        messages = [\n            {\"role\": \"user\", \"content\": system_prompt + \"\\n\\n\" + user_message},\n        ]\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            return [str(q).strip() for q in data.get(\"queries\", []) if q]\n        except Exception as e:\n            print(\"批量reflect解析失败:\", e)\n            return []\n\n\n    #为避免出现过于相似或者重复的gap，generate后使用filter去重\n    def _filter_and_update_gaps(self, gaps, new_gaps=None):\n        #print(\"过滤更新 运行到了\")\n        \"\"\"\n        对gaps去重，并更新已处理过的gaps集合。\n        如果提供了new_gaps，则只处理new_gaps，否则处理gaps。\n        返回未被处理过的新gap列表。\n        \"\"\"\n        target_gaps = new_gaps if new_gaps is not None else gaps\n        filtered = [g for g in target_gaps if g not in self.processed_gaps]\n        self.processed_gaps.update(filtered)\n        return filtered\n\n    #此处规范化result，保证知识库内信息不为空\n    def format_search_result(self, result: dict) -> str:\n        #print(\"格式化结果 运行到了\")\n        \"\"\"\n        泛用型，将搜索结果dict转为可读文本。\n        1. 如果是字符串，直接返回；\n        2. 如果是列表，则递归格式化每项，合并输出；\n        3. 如果是dict，尝试读取常见字段，如title、content、summary等，并递归格式化；\n        4. 如果有error，则优先返回error文本；\n        5. 其它类型，直接转字符串。\n        \"\"\"\n        if not result:\n            return \"（无搜索结果）\"\n        if isinstance(result, str):\n            return result.strip()\n        if isinstance(result, list):\n            # 多条结果，递归格式化每条\n            return \"\\n\".join(self.format_search_result(item) for item in result)\n        if isinstance(result, dict):\n            if \"error\" in result and result[\"error\"]:\n                return f\"查询失败：{result['error']}\"\n            # 优先展示result字段\n            if \"result\" in result:\n                # result字段本身可能是字符串、dict或list\n                return self.format_search_result(result[\"result\"])\n            # 常见内容字段\n            text_pieces = []\n            for key in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\"):\n                if key in result and result[key]:\n                    text_pieces.append(str(result[key]).strip())\n            # 其它字段也拼一下\n            other_keys = [k for k in result if\n                          k not in (\"title\", \"question\", \"summary\", \"content\", \"description\", \"answer\", \"error\",\n                                    \"result\") and result[k]]\n            for k in other_keys:\n                text_pieces.append(f\"{k}: {result[k]}\")\n            if text_pieces:\n                return \"\\n\".join(text_pieces)\n            # 如果没有可用字段，直接输出dict\n            return str(result)\n        # 其它类型\n        return str(result)\n\n    #最后一步，生成最终报告\n    async def generate_final_answer(self, global_question: str, knowledge: list[dict]) -> (str, bool):\n        print(\"生成最终答案 运行到了\")\n        \"\"\"\n        用LLM综合知识库和global question生成最终答案，并判断是否还需补充信息。\n        返回：(最终答案, 需补充True/False)\n        \"\"\"\n        # 将知识库内容整理成可阅读的字符串\n        knowledge_text = \"\\n\\n\".join(\n            f\"【子问题】：{item.get('gap', '')}\\n【内容】：{item.get('summary', '')}\" for item in knowledge\n        )\n\n        prompt = f\"\"\"\n    你现在是一位专业问答助手。请根据下方已收集的知识点，回答全局问题。\n    如果你认为已有知识完全可以支持准确回答，请给出最终答案，并标记\"need_more\"为false；如果你认为知识还不够，无法回答或有重大遗漏，请标记\"need_more\"为true，并简要说明原因。\n    只允许输出如下JSON格式（不要有任何其他内容）：\n\n    {{\n      \"answer\": \"最终答案内容\",\n      \"need_more\": true/false,\n      \"reason\": \"如需补充知识，说明原因，否则可省略\"\n    }}\n\n    全局问题：{global_question}\n\n    知识库内容：\n    {knowledge_text}\n    \"\"\"\n        messages = [\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        #print(f'最终答案生成message{messages}')\n        response = await self.llm.ask(messages)\n        try:\n            data = json.loads(response.content)\n            answer = data.get(\"answer\", \"\").strip()\n            need_more = bool(data.get(\"need_more\", False))\n            print(\"最终答案生成成功\")\n            return answer, need_more\n        except Exception:\n            # 解析失败时降级为“无法回答，需补充”\n            return \"（无法解析LLM的回答，请补充知识）\", True\n\n    # ========== 可选 summary/report 接口 ==========\n    # 两个方法视情况使用，目前在代码中并未用到\n\n    async def summarize_execution(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程执行总结\")\n        # 可以输出 self.knowledge 等\n\n    async def generate_report(self) -> AsyncGenerator[AgentEvent, None]:\n        yield MessageEvent(message=\"搜索流程最终报告\")\n",
      "methods": [
        "<module>.SearchFlow.__init__",
        "<module>.SearchFlow.is_idle",
        "<module>.SearchFlow.run",
        "<module>.SearchFlow.select_scoring_mode",
        "<module>.SearchFlow.generate_gaps",
        "<module>.SearchFlow.search_gap",
        "<module>.SearchFlow.score_gap",
        "<module>.SearchFlow._get_prompts",
        "<module>.SearchFlow.analyze_gap",
        "<module>.SearchFlow.reflect_gap",
        "<module>.SearchFlow.reflect_gap_batch",
        "<module>.SearchFlow._filter_and_update_gaps",
        "<module>.SearchFlow.format_search_result",
        "<module>.SearchFlow.generate_final_answer",
        "<module>.SearchFlow.summarize_execution",
        "<module>.SearchFlow.generate_report"
      ],
      "description": "A flow controller that coordinates generation of gaps, search and evaluation of gap results via an executor, reflection to generate new gaps, and final answer generation using an LLM; it maintains an in-memory knowledge base of gaps and summaries, supports iterative refinement, and emits AgentEvent objects to report progress and results."
    },
    {
      "file": "/app/sample_workspace/flows/code_flow.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "Enumeration of the CodeFlow lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING) used to coordinate between planning, execution, updating, and reporting phases."
    },
    {
      "file": "/app/sample_workspace/flows/code_flow.py",
      "name": "CodeFlow",
      "qualname": "<module>.CodeFlow",
      "source": "class CodeFlow(BaseSubFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"code\"\n    description = \"子计划规划流程：先创建子计划，然后逐步执行，支持动态更新子计划\"\n    \n    def __init__(\n        self,\n        llm: LLM,\n        sandbox: Sandbox,\n        browser: Browser,\n        search_engine: Optional[SearchEngine] = None,\n        audio_llm: Optional[AudioLLM] = None,\n        image_llm: Optional[ImageLLM] = None,\n        video_llm: Optional[VideoLLM] = None,\n        reason_llm: Optional[ReasonLLM] = None,\n        task_type: Enum = None,\n    ):\n        # 设置专门的日志记录器\n        self.sub_planner_flow_logger = setup_sub_planner_flow_logger(f\"sub_planner_{task_type.value if task_type else 'unknown'}\")\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow初始化 任务类型: {task_type.value if task_type else 'None'} ===\")\n        \n        # 添加详细的调试日志\n        self.sub_planner_flow_logger.info(f\"=== CodeFlow.__init__ 开始 ===\")\n        self.sub_planner_flow_logger.info(f\"接收到的参数:\")\n        self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n        self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n        self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n        self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n        self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n        self.execution_result=Memory()\n        if task_type:\n            self.sub_planner_flow_logger.info(f\"task_type.value: {task_type.value}\")\n            self.sub_planner_flow_logger.info(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 调用父类构造函数\n        super().__init__(\n            llm=llm,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            task_type=task_type,\n        )\n        \n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        self.sub_planner_flow_logger.info(f\"=== 开始创建SubPlannerAgent ===\")\n        \n        try:\n            # 创建子规划器代理\n            self.sub_planner_flow_logger.info(f\"准备创建SubPlannerAgent，参数:\")\n            self.sub_planner_flow_logger.info(f\"  llm: {llm}\")\n            self.sub_planner_flow_logger.info(f\"  task_type: {task_type} (类型: {type(task_type)})\")\n            self.sub_planner_flow_logger.info(f\"  sandbox: {sandbox}\")\n            self.sub_planner_flow_logger.info(f\"  browser: {browser}\")\n            self.sub_planner_flow_logger.info(f\"  search_engine: {search_engine}\")\n            \n            self.sub_planner = SubPlannerAgent(\n                llm=llm,\n                task_type=task_type,\n                memory=Memory(),\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n            )\n            self.sub_planner.system_prompt = PromptManager.get_system_prompt_with_tools(self.sub_planner.tools, is_executor=False, is_code=True)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(self.sub_planner.system_prompt)\n            self.sub_planner_flow_logger.info(\"创建SubPlanner Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建SubPlannerAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n        \n        try:\n            self.sub_planner_flow_logger.info(f\"=== 开始创建ExecutionAgent ===\")\n            # 创建执行代理\n            self.executor = ExecutionAgent(\n                memory=Memory(),\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                type_value=task_type.value\n            )\n            \n            self.sub_planner_flow_logger.info(\"创建Execution Agent完成\")\n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"创建ExecutionAgent失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n\n    async def run(\n        self,\n        parent_plan: Plan,\n        parent_step: Step,\n        parent_memory: Memory,\n        task_type: Enum\n    ) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行子计划流程\n        \n        Args:\n            parent_plan: 父规划器当前的计划\n            parent_step: 要执行的步骤\n            parent_memory: 父规划器当前的记忆\n            task_type: 当前步骤的任务类型\n        \"\"\"\n        \n        self.sub_planner.fix(parent_plan,parent_step)\n\n        self.sub_planner_flow_logger.info(f\"=== 开始执行子计划 ===\")\n        self.sub_planner_flow_logger.info(f\"父计划ID: {parent_plan.id}\")\n        self.sub_planner_flow_logger.info(f\"父步骤ID: {parent_step.id}\")\n        self.sub_planner_flow_logger.info(f\"任务类型: {task_type.value}\")\n        \n        # 根据传入的task_type更新提示词\n        self.sub_planner_flow_logger.info(f\"=== 开始更新系统提示词 ===\")\n        \n        try:\n            updated_system_prompt = self.sub_planner.system_prompt\n            updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n            updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n            self.sub_planner.system_prompt = PromptManager.insert_datetime(updated_system_prompt)\n            # Debug: print\n            # TODO: remove this\n            self.sub_planner_flow_logger.info(f\"updated_system_prompt: {updated_system_prompt}\")\n            \n        except Exception as e:\n            self.sub_planner_flow_logger.error(f\"更新系统提示词失败: {str(e)}\")\n            self.sub_planner_flow_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.sub_planner_flow_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            # 继续执行，不因为提示词更新失败而中断整个流程\n            \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.sub_planner.roll_back()\n            self.executor.roll_back()\n            self.sub_planner_flow_logger.info(\"中断当前流程，重新开始规划\")\n\n        # 使用父步骤的描述作为输入消息\n        message = parent_step.description\n        logger.info(f\"开始处理步骤: {message[:50]}...\")\n        \n        # 创建子计划\n        self.status = AgentStatus.PLANNING\n        self.sub_planner_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n        \n        \n        async for event in self.sub_planner.create_plan(message):\n            \n            if isinstance(event, PlanCreatedEvent):\n                self.plan = event.plan\n                logger.info(f\"创建子计划成功，包含 {len(event.plan.steps)} 个步骤\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划创建成功 ===\")\n                self.sub_planner_flow_logger.info(f\"子计划ID: {event.plan.id}\")\n                self.sub_planner_flow_logger.info(f\"子计划目标: {event.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"子计划标题: {event.plan.title}\")\n                self.sub_planner_flow_logger.info(f\"子计划步骤数量: {len(event.plan.steps)}\")\n                for i, step in enumerate(event.plan.steps, 1):\n                    self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                if event.plan.message:\n                    self.sub_planner_flow_logger.info(f\"子计划说明: {event.plan.message}\")\n            elif isinstance(event, MessageEvent):\n                self.sub_planner_flow_logger.info(f\"Planner输出: {event.message}\")\n            yield event\n            \n        self.status = AgentStatus.EXECUTING\n        self.sub_planner_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n        \n        # 执行子计划\n        while True:\n            if self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"子计划执行完成，状态变更: EXECUTING -> REPORTING\")\n                    self.status = AgentStatus.REPORTING\n                    self.sub_planner_flow_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                \n                # 执行步骤\n                logger.info(f\"开始执行步骤 {step.id}: {step.description[:50]}...\")\n                self.sub_planner_flow_logger.info(f\"=== 开始执行步骤 ===\")\n                self.sub_planner_flow_logger.info(f\"步骤ID: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤描述: {step.description}\")\n                self.sub_planner_flow_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    \n                    updated_system_prompt = self.executor.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.executor.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.executor.memory)\n                    \n                    self.executor.system_prompt = updated_system_prompt\n                    if isinstance(event, ToolCallingEvent):\n                        self.sub_planner_flow_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.sub_planner_flow_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具函数: {event.function_name}\")\n                        self.sub_planner_flow_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.sub_planner_flow_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"Executor输出: {event.message}\")\n                        # 将执行结果保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n                        \n                logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                self.sub_planner_flow_logger.info(f\"步骤执行完成: {step.id}\")\n                self.sub_planner_flow_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.sub_planner_flow_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.sub_planner_flow_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.sub_planner_flow_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为\n                self.sub_planner_flow_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"步骤总结完成: {event.message}\")\n                        previous_steps = event.message\n                        self.sub_planner_flow_logger.info(f\"步骤总结完成: {event.message}\")\n                        # 将总结保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                        \n                # 更新计划\n                self.sub_planner_flow_logger.info(f\"=== 开始更新子计划 ===\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.sub_planner_flow_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                updated_system_prompt = self.sub_planner.system_prompt\n                updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                \n                self.sub_planner.system_prompt = updated_system_prompt\n                async for event in self.sub_planner.update_plan(self.plan, previous_steps):\n                    \n                    updated_system_prompt = self.sub_planner.system_prompt\n                    updated_system_prompt = await PromptManager.update_ls(updated_system_prompt, self.sub_planner.shell_tool)\n                    updated_system_prompt = PromptManager.update_mem(updated_system_prompt, self.sub_planner.memory)\n                    self.sub_planner.system_prompt = updated_system_prompt\n                    \n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.sub_planner_flow_logger.info(f\"=== 子计划更新完成 ===\")\n                        self.sub_planner_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.sub_planner_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.sub_planner_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 将更新信息保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"子计划更新完成，状态变更: UPDATING -> EXECUTING\")\n                self.status = AgentStatus.EXECUTING\n                self.sub_planner_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"子计划执行完成，准备生成报告\")\n                self.sub_planner_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                async for event in self.executor.report_result(message):\n                    if isinstance(event, MessageEvent):\n                        # 将报告保存到execution_result中\n                        self.execution_result.add_message({\n                            \"role\": \"assistant\",\n                            \"content\": event.message\n                        })\n                    yield event\n\n                yield ReportEvent(message=str(self.execution_result.get_messages()))\n                self.status = AgentStatus.COMPLETED\n                self.sub_planner_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"子计划执行完成\")\n                self.sub_planner_flow_logger.info(f\"=== 子计划执行完成 ===\")\n                self.sub_planner_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan,issubplan=True) \n                self.status = AgentStatus.IDLE\n                self.sub_planner_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n                \n        #yield DoneEvent()\n        \"\"\"需要声明另一种doneevent\"\"\"\n\n        \n        logger.info(f\"子计划处理完成\")\n        self.sub_planner_flow_logger.info(f\"=== 子计划处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.CodeFlow.__init__",
        "<module>.CodeFlow.run",
        "<module>.CodeFlow.is_idle",
        "<module>.CodeFlow._show_plan"
      ],
      "description": "A BaseSubFlow-based orchestrator that creates and manages a SubPlannerAgent and an ExecutionAgent to generate a sub-plan from a parent plan/step, execute it step-by-step, dynamically update the plan as needed, and finally compile a result report. It coordinates prompt and memory updates, handles events from the sub-planner and executor, and emits higher-level events (PlanCreatedEvent, PlanCompletedEvent, ReportEvent) to the caller."
    },
    {
      "file": "/app/sample_workspace/flows/factory.py",
      "name": "FlowFactory",
      "qualname": "<module>.FlowFactory",
      "source": "class FlowFactory:\n    \"\"\"Flow工厂类,负责管理和创建不同类型的flow\"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的flow类型\n        self._flow_classes: Dict[str, Type[BaseFlow]] = {}\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的flow类型\"\"\"\n        self.register_flow(PlanActFlow)\n        self.register_flow(SimpleChatFlow)\n        # 延迟导入 SuperPlannerFlow 以避免循环导入\n        from app.domain.services.flows.super_flow import SuperFlow\n        self.register_flow(SuperFlow)\n        logger.info(\"已注册默认flow类型\")\n    \n    def register_flow(self, flow_class: Type[BaseFlow]) -> None:\n        \"\"\"注册新的flow类型\"\"\"\n        if not issubclass(flow_class, BaseFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        logger.info(f\"已注册flow类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self, flow_id: str, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, \n                   browser: Browser, search_engine: Optional[SearchEngine] = None, \n                   **kwargs) -> BaseFlow:\n        \"\"\"根据flow_id创建对应的flow实例\"\"\"\n    \n        \n        if flow_id not in self._flow_classes:\n            available_flows = list(self._flow_classes.keys())\n            raise ValueError(f\"未知的flow类型: {flow_id}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_id]\n        \n        try:\n            # 创建flow实例，传递所有必要的参数\n            flow_instance = flow_class(\n                agent=agent,\n                llm=llm,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                **kwargs\n            )\n            logger.info(f\"成功创建flow实例: {flow_id} for Agent {agent.id}\")\n            return flow_instance\n        except Exception as e:\n            logger.error(f\"创建flow实例失败: {flow_id}, 错误: {str(e)}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的flow类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n    \n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的flow类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseFlow]]:\n        \"\"\"获取指定flow_id对应的flow类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.FlowFactory.__init__",
        "<module>.FlowFactory._register_default_flows",
        "<module>.FlowFactory.register_flow",
        "<module>.FlowFactory.create_flow",
        "<module>.FlowFactory.get_available_flows",
        "<module>.FlowFactory.has_flow",
        "<module>.FlowFactory.get_flow_class"
      ],
      "description": "Central factory responsible for registering and instantiating high-level flow objects, and querying available flows and their metadata."
    },
    {
      "file": "/app/sample_workspace/flows/factory.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    CODE = \"code\"\n    REASONING = \"reasoning\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "Enum used to categorize sub-flow tasks (CODE, REASONING, SEARCH, FILE) for internal redirection and mapping."
    },
    {
      "file": "/app/sample_workspace/flows/factory.py",
      "name": "SubFlowFactory",
      "qualname": "<module>.SubFlowFactory",
      "source": "class SubFlowFactory:\n    \"\"\"\n    子流程工厂类\n    负责创建和管理所有子流程实例\n    \"\"\"\n    \n    def __init__(self):\n        # 注册所有可用的子流程类型\n        self._flow_classes: Dict[str, Type[BaseSubFlow]] = {}\n        \n        # 设置专门的日志记录器\n        self.factory_logger = setup_sub_planner_flow_logger(\"SubFlowFactory\")\n        self.factory_logger.info(f\"=== SubFlowFactory初始化 ===\")\n        \n        # 注册默认流程\n        self._register_default_flows()\n    \n    def _register_default_flows(self):\n        \"\"\"注册默认的子流程类型\"\"\"\n        self.register_flow(DefaultFlow)\n        self.register_flow(SearchFlow)\n        self.register_flow(CodeFlow)\n        self.factory_logger.info(\"已注册默认子流程类型\")\n    \n    def register_flow(self, flow_class: Type[BaseSubFlow]) -> None:\n        \"\"\"注册新的子流程类型\"\"\"\n        if not issubclass(flow_class, BaseSubFlow):\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须继承自BaseSubFlow\")\n        \n        flow_id = flow_class.get_flow_id()\n        if not flow_id:\n            raise ValueError(f\"Flow类 {flow_class.__name__} 必须定义flow_id\")\n        \n        if flow_id in self._flow_classes:\n            self.factory_logger.warning(f\"Flow ID '{flow_id}' 已存在，将被覆盖\")\n        \n        self._flow_classes[flow_id] = flow_class\n        self.factory_logger.info(f\"已注册子流程类型: {flow_id} -> {flow_class.__name__}\")\n    \n    def create_flow(self,\n                    llm: LLM,\n                    task_type: Enum,\n                    sandbox: Sandbox,\n                    browser: Browser,\n                    search_engine: Optional[SearchEngine] = None,\n                    audio_llm: Optional[AudioLLM] = None,\n                    image_llm: Optional[ImageLLM] = None,\n                    video_llm: Optional[VideoLLM] = None,\n                    reason_llm: Optional[ReasonLLM] = None,\n                    ) -> BaseSubFlow:\n        \"\"\"根据任务类型创建对应的子流程实例\"\"\"\n        # 添加详细的调试日志\n        self.factory_logger.info(f\"=== create_flow 开始 ===\")\n        self.factory_logger.debug(f\"task_type 参数: {task_type}\")\n        self.factory_logger.debug(f\"task_type 类型: {type(task_type)}\")\n        self.factory_logger.debug(f\"task_type.value 类型: {type(task_type.value)}\")\n        \n        # 获取实际的 flow_type\n        flow_type = task_type.value\n       # self.factory_logger.info(f\"flow_type: {flow_type}\")\n      #  self.factory_logger.debug(f\"可用的flow类型: {list(self._flow_classes.keys())}\")\n            \n        # 重定向逻辑：所有 -> general sub flow\n        if flow_type == \"search\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向\")\n        elif flow_type == \"code\":\n            self.factory_logger.info(f\"flow_type {flow_type} 不重定向 \")\n        elif flow_type == \"file\":\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        elif flow_type == 'reasoning':\n            self.factory_logger.info(f\"flow_type {flow_type} 重定向到general_flow\")\n            flow_type = \"default\"\n        else:\n            available_flows = list(self._flow_classes.keys())\n            self.factory_logger.error(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n            raise ValueError(f\"未知的子流程类型: {flow_type}. 可用类型: {available_flows}\")\n        \n        flow_class = self._flow_classes[flow_type]\n        self.factory_logger.debug(f\"选择的flow_class: {flow_class}\")\n        self.factory_logger.debug(f\"flow_class 类型: {type(flow_class)}\")\n        \n        try:\n            self.factory_logger.info(f\"=== 开始创建flow实例 ===\")\n            self.factory_logger.debug(f\"检查flow_class是否在预期列表中: {flow_class in [DefaultFlow, SearchFlow, CodeFlow]}\")\n            \n            # 针对不同子类传递不同参数\n            # self.factory_logger.debug(f\"使用完整参数创建flow实例\")\n            # self.factory_logger.debug(f\"传递的参数:\")\n            # self.factory_logger.debug(f\"llm: {llm}\")\n            # self.factory_logger.debug(f\"sandbox: {sandbox}\")\n            # self.factory_logger.debug(f\"browser: {browser}\")\n            # self.factory_logger.debug(f\"search_engine: {search_engine}\")\n            # self.factory_logger.debug(f\"task_type: {task_type} (类型: {type(task_type)})\")\n\n            flow_instance = flow_class(\n                llm=llm,\n                sandbox=sandbox,\n                browser=browser,\n                search_engine=search_engine,\n                audio_llm=audio_llm,\n                image_llm=image_llm,\n                video_llm=video_llm,\n                reason_llm=reason_llm,\n                task_type=task_type,\n            )\n            self.factory_logger.info(f\"成功创建子流程实例: {flow_type}\")\n            return flow_instance\n        except Exception as e:\n            self.factory_logger.error(f\"创建子流程实例失败: {flow_type}, 错误: {str(e)}\")\n            self.factory_logger.error(f\"错误类型: {type(e)}\")\n            import traceback\n            self.factory_logger.error(f\"错误堆栈: {traceback.format_exc()}\")\n            raise\n    \n    def get_available_flows(self) -> List[Dict[str, str]]:\n        \"\"\"获取所有可用的子流程类型信息\"\"\"\n        flows = []\n        for flow_id, flow_class in self._flow_classes.items():\n            flows.append({\n                \"flow_id\": flow_id,\n                \"name\": flow_class.__name__,\n                \"description\": flow_class.get_description()\n            })\n        return flows\n\n    def get_available_flows_enum(self,enum_name: str = \"SubPlannerType\") -> type[Enum]:\n        flows = self.get_available_flows()\n        # 构造枚举成员字典: { \"MESSAGE\": \"message\", ... }\n        enum_members = {}\n        for flow in flows:\n            raw_name = flow[\"name\"]\n            enum_key = raw_name.replace(\"Flow\", \"\").upper()\n            enum_value = flow[\"flow_id\"]\n            enum_members[enum_key] = enum_value\n\n        # 使用 type() + EnumMeta 创建类\n        return Enum(enum_name, enum_members)\n\n    def has_flow(self, flow_id: str) -> bool:\n        \"\"\"检查是否存在指定的子流程类型\"\"\"\n        return flow_id in self._flow_classes\n    \n    def get_flow_class(self, flow_id: str) -> Optional[Type[BaseSubFlow]]:\n        \"\"\"获取指定flow_id对应的子流程类\"\"\"\n        return self._flow_classes.get(flow_id)\n",
      "methods": [
        "<module>.SubFlowFactory.__init__",
        "<module>.SubFlowFactory._register_default_flows",
        "<module>.SubFlowFactory.register_flow",
        "<module>.SubFlowFactory.create_flow",
        "<module>.SubFlowFactory.get_available_flows",
        "<module>.SubFlowFactory.get_available_flows_enum",
        "<module>.SubFlowFactory.has_flow",
        "<module>.SubFlowFactory.get_flow_class"
      ],
      "description": "Dedicated factory for registering, selecting, and creating sub-flow instances with detailed logging and redirect rules based on task types."
    },
    {
      "file": "/app/sample_workspace/flows/simple_chat.py",
      "name": "SimpleChatFlow",
      "qualname": "<module>.SimpleChatFlow",
      "source": "class SimpleChatFlow(BaseFlow):\n    \"\"\"简单聊天流程：直接与LLM对话，不进行计划和执行\"\"\"\n    \n    # 定义flow的唯一标识符\n    flow_id = \"simple_chat\"\n    description = \"简单聊天流程：直接与LLM对话，适用于简单的问答场景\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.llm = llm\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self._is_idle = True\n        logger.debug(f\"Created SimpleChatFlow for Agent {self.agent.id}\")\n    \n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"执行简单聊天流程\"\"\"\n        self._is_idle = False\n        logger.info(f\"Agent {self.agent.id} started simple chat with message: {message[:50]}...\")\n        \n        try:\n            # 构建简单的提示词\n            prompt = f\"\"\"你是一个有用的AI助手。请回答用户的问题。\n\n用户问题: {message}\n\n请提供有用和准确的回答：\"\"\"\n            \n            # 调用LLM获取回复\n            response = await self.llm.ask(\n                messages=[{\"role\": \"user\", \"content\": prompt}],\n            )\n            \n            # 发送回复事件\n            yield MessageEvent(message=response.content)\n            logger.info(f\"Agent {self.agent.id} completed simple chat response\")\n            \n        except Exception as e:\n            logger.error(f\"Agent {self.agent.id} simple chat failed: {str(e)}\")\n            yield MessageEvent(message=f\"抱歉，处理您的请求时出现错误：{str(e)}\")\n        \n        finally:\n            self._is_idle = True\n            yield DoneEvent()\n    \n    def is_idle(self) -> bool:\n        \"\"\"检查flow是否处于空闲状态\"\"\"\n        return self._is_idle ",
      "methods": [
        "<module>.SimpleChatFlow.__init__",
        "<module>.SimpleChatFlow.run",
        "<module>.SimpleChatFlow.is_idle"
      ],
      "description": "A simple, direct-chat flow that delegates user queries to an LLM and emits MessageEvent responses; it maintains an idle state and interacts with various external services (LLMs, Sandbox, Browser, optional SearchEngine) and event types to drive the conversation."
    },
    {
      "file": "/app/sample_workspace/flows/super_flow.py",
      "name": "FlowStatus",
      "qualname": "<module>.FlowStatus",
      "source": "class FlowStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "Enumeration of the SuperFlow lifecycle states (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING), used to steer the main run loop and transitions."
    },
    {
      "file": "/app/sample_workspace/flows/super_flow.py",
      "name": "SuperFlow",
      "qualname": "<module>.SuperFlow",
      "source": "class SuperFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"TreeFLow\"\n    description = \"a flow that uses multiple planners to handle complex tasks\"\n\n    def __init__(self, agent: Agent, llm: LLM, sandbox: Sandbox, browser: Browser,\n                 search_engine: Optional[SearchEngine] = None, \n                 audio_llm: Optional[AudioLLM] = None,\n                 image_llm: Optional[ImageLLM] = None,\n                 video_llm: Optional[VideoLLM] = None,\n                 reason_llm: Optional[ReasonLLM] = None,\n                 **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = FlowStatus.IDLE\n\n        # 设置专门的日志记录器\n        self.super_flow_logger = setup_super_planner_flow_logger(\"SuperPlannerFlow\")\n        self.super_flow_logger.info(f\"=== SuperPlannerFlow初始化 Agent ID: {agent.id} ===\")\n\n        # 初始化可用的基础设施\n        self.llm = llm\n        self.sandbox = sandbox\n        self.browser = browser\n        self.search_engine = search_engine\n        self.audio_llm = audio_llm\n        self.image_llm = image_llm\n        self.video_llm = video_llm\n        self.reason_llm = reason_llm\n\n        # 初始化planner memory\n        self.planner_memory = Memory()\n        # 初始化knowledge memory\n        self.knowledge = Memory()\n\n        # 创建 planer agent\n        self.planner_agent = PlannerAgent(\n            llm=llm,\n            memory = self.planner_memory,\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Planner Agent完成\")\n\n        self.report_agent = ReportAgent(\n            llm=llm,\n            memory = Memory(),\n            knowledge=self.knowledge,\n        )\n        self.super_flow_logger.debug(f\"创建Report Agent完成\")\n\n        # 创建 sub_flow_factory\n        from app.domain.services.flows.factory import sub_flow_factory\n        self.sub_flow_factory = sub_flow_factory\n        self.sub_flow_type = self.sub_flow_factory.get_available_flows_enum()\n\n        # 创建通知代理，通知用户进度\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),\n        )\n        self.super_flow_logger.debug(f\"创建Notify Agent完成\")\n\n        # 用于控制流和并发实现\n        # 按照并发组划分的sub planner\n        self.parallel_sub_flow_groups = None\n        # 记录使用过的sub planner\n        self.sub_flow_instance_used = []\n        # 管理活动的子规划器\n        self._active_sub_flow: Dict[str, BaseSubFlow] = {}\n        # 记录子规划器的执行历史\n        self._sub_flow_history: Dict[str, Dict] = {}\n\n\n    @staticmethod\n    def _determine_task_type(description: str) -> str:\n        \"\"\"\n        根据步骤描述确定流程类型\n        \"\"\"\n        description_lower = description.lower()\n        if any(cmd in description_lower for cmd in [\"run\", \"execute\", \"command\", \"shell\"]):\n            return \"code\"\n        elif any(cmd in description_lower for cmd in [\"browse\", \"visit\", \"web\", \"url\", \"search\", \"find\", \"lookup\"]):\n            return \"search\"\n        elif any(cmd in description_lower for cmd in [\"reason\", \"think\", \"analyze\", \"deduce\", \"infer\"]):\n            return \"reasoning\"\n        elif any(cmd in description_lower for cmd in [\"file\", \"document\", \"read\", \"write\", \"process\"]):\n            return \"file\"\n        else:\n            return \"search\" # 默认使用搜索流程\n\n\n    async def execute_step(self, step: Step) -> AsyncGenerator[AgentEvent, None]:\n        \"\"\"\n        执行计划中的单个步骤\n        根据步骤类型创建对应的子流程并执行\n        \"\"\"\n        self.super_flow_logger.info(f\"执行子任务步骤 {step.id}: {step.description}\")\n        \n        # 确定任务类型\n        if step.sub_flow_type:\n            # 添加调试信息\n            self.super_flow_logger.debug(f\"step.sub_flow_type 类型: {type(step.sub_flow_type)}\")\n\n            # 标准化处理\n            if isinstance(step.sub_flow_type, str):\n                # 如果是字符串，转换为 SubPlannerType 枚举\n                task_type = self.sub_flow_type(step.sub_flow_type.lower())\n                self.super_flow_logger.debug(f\"字符串转换为枚举: {task_type}\")\n            else:\n                # 如果是枚举，直接使用\n                task_type = step.sub_flow_type\n                self.super_flow_logger.debug(f\"使用枚举: {task_type}\")\n\n            self.super_flow_logger.debug(f\"使用 SuperPlanner 指定的任务类型: {task_type}\")\n        else:\n            # 如果没有指定，才根据描述判断\n            task_type = self._determine_task_type(step.description)\n            self.super_flow_logger.debug(f\"根据描述推断的任务类型: {task_type}\")\n\n        # 创建新的子规划器 SubFlow\n        sub_flow = self.sub_flow_factory.create_flow(\n            llm=self.llm,\n            task_type=task_type,\n            sandbox=self.sandbox,\n            browser=self.browser,\n            search_engine=self.search_engine,\n            audio_llm=self.audio_llm,\n            image_llm=self.image_llm,\n            video_llm=self.video_llm,\n            reason_llm=self.reason_llm,\n        )\n\n        step.status = ExecutionStatus.RUNNING\n        yield StepStartedEvent(step=step, plan=self.plan)\n\n        try:\n            async for event in sub_flow.run(\n                parent_plan = self.plan,\n                parent_step = step,\n                parent_memory = self.knowledge,\n                task_type = task_type,\n            ):\n                # sub flow返回值处理 \n                if isinstance(event, ErrorEvent):\n                    step.status = ExecutionStatus.FAILED\n                    step.error = event.error\n                    yield StepFailedEvent(step=step, plan=self.plan)\n                    return\n\n                if isinstance(event, PauseEvent):\n                    yield event\n                    return\n\n                if isinstance(event, MessageEvent):\n                    step.status = ExecutionStatus.COMPLETED\n                    step.result = event.message\n                    yield StepCompletedEvent(step=step, plan=self.plan)\n                \n                # 只转发 ReportEvent，但转换为更简洁的消息\n                if isinstance(event, ReportEvent):\n                    yield MessageEvent(message=f\"✅ {step.description} - 完成\")\n                # 完全过滤掉实现细节：ToolCallingEvent, ToolCalledEvent, MessageEvent, \n                # PlanCreatedEvent, PlanUpdatedEvent, PlanCompletedEvent, DoneEvent\n                # ErrorEvent 和 PauseEvent 已在上面单独处理\n\n        except Exception as e:\n\n            step.status = ExecutionStatus.FAILED\n            step.error = str(e)\n            yield StepFailedEvent(step=step, plan=self.plan)\n            return\n\n        step.status = ExecutionStatus.COMPLETED\n\n\n    def _build_parallel_execution_groups(self) -> Optional[deque]:\n        # Concurrent Execution Groups\n        self.parallel_sub_flow_groups = []\n        prev_step = -1\n        for i in range(len(self.plan.steps)):\n            step = self.plan.steps[i]\n            try:\n                # 0. 跳过已完成或失败的步骤\n                if step.status in [ExecutionStatus.COMPLETED, ExecutionStatus.FAILED]:\n                    self.super_flow_logger.debug(\n                        f\"跳过已完成/失败的步骤 {step.id}: {step.description} (状态: {step.status})\")\n                    continue\n\n                # 1. 安全地处理 subplan_step 转换\n                if not step.sub_plan_step:\n                    self.super_flow_logger.error(f\"步骤 {step.id} 缺少 subplan_step 属性\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = \"Missing subplan_step attribute\"\n                    continue\n\n                try:\n                    cur_step = int(step.sub_plan_step)\n                except ValueError:\n                    self.super_flow_logger.error(\n                        f\"步骤 {step.id} 的 subplan_step 值 '{step.sub_plan_step}' 无法转换为整数\")\n                    step.status = ExecutionStatus.FAILED\n                    step.error = f\"Invalid subplan_step value: {step.sub_plan_step}\"\n                    continue\n\n                # 2. 检查步骤顺序\n                if cur_step < prev_step:\n                    error_msg = f\"步骤顺序错误：当前步骤 {step.id} (subplan_step={cur_step}) 小于前一步骤 (subplan_step={prev_step})\"\n                    self.super_flow_logger.error(error_msg)\n                    step.status = ExecutionStatus.FAILED\n                    step.error = error_msg\n                    continue\n\n                # 3. 正常的步骤处理逻辑\n                if cur_step > prev_step:\n                    # case 1: this step is a new step\n                    self.parallel_sub_flow_groups.append([step])\n                    prev_step = cur_step\n                elif cur_step == prev_step:\n                    # case 2: this step is the same step as the previous step\n                    self.parallel_sub_flow_groups[-1].append(step)\n\n            except Exception as e:\n                error_msg = f\"处理步骤 {step.id} 时发生错误: {str(e)}\"\n                self.super_flow_logger.error(error_msg)\n                step.status = ExecutionStatus.FAILED\n                step.error = error_msg\n                continue\n\n        self.parallel_sub_flow_groups = deque(self.parallel_sub_flow_groups)\n        self.super_flow_logger.info(\n            f\"构建了 {len(self.parallel_sub_flow_groups)} 个执行组，共 {sum(len(group) for group in self.parallel_sub_flow_groups)} 个待执行步骤\")\n\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        \n        self.super_flow_logger.info(f\"=== Super Flow开始处理用户消息 ===\")\n        self.super_flow_logger.info(f\"用户输入: {message}\")\n        step = None\n\n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = FlowStatus.PLANNING\n            self.planner_agent.roll_back()\n            self.report_agent.roll_back()\n            self.super_flow_logger.debug(\"中断当前流程，重新开始规划\")\n\n        while True:\n            if self.status == FlowStatus.IDLE:\n                self.status = FlowStatus.PLANNING\n                self.super_flow_logger.info(f\"状态变更: IDLE -> PLANNING\")\n\n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                  \n                    if not isinstance(event, MessageEvent):\n                        yield event\n\n            elif self.status == FlowStatus.PLANNING:\n                # 创建计划\n                self.super_flow_logger.info(f\"=== Super Flow开始创建计划 ===\")\n             #   self.super_flow_logger.debug(f\"Super Planner输入: {message}\")\n\n                async for event in self.planner_agent.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        self.super_flow_logger.info(f\"=== 计划创建成功 ===\")\n                        self.super_flow_logger.debug(f\"计划ID: {event.plan.id}\")\n                        self.super_flow_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.super_flow_logger.debug(f\"计划标题: {event.plan.title}\")\n                        self.super_flow_logger.debug(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.super_flow_logger.debug(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.super_flow_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.warning(f\"Planner输出MessageEvent: {event.message}\")\n               #     yield event\n\n                # 创建计划完成后，准备执行步骤\n                if self.plan:\n                    self._build_parallel_execution_groups()\n                    # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                    if not self.parallel_sub_flow_groups:\n                        self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                        self.status = FlowStatus.REPORTING\n                        continue\n                    # 状态转换到执行阶段\n                    self.status = FlowStatus.EXECUTING\n                    self.super_flow_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n\n            elif self.status == FlowStatus.EXECUTING:\n                self.plan.status = ExecutionStatus.RUNNING\n\n                if not self.parallel_sub_flow_groups:\n                    self.status = FlowStatus.REPORTING\n                    self.super_flow_logger.info(\"状态变更: EXECUTING -> REPORTING\")\n                    continue\n                # 并发处理\n                current_parallel_group = self.parallel_sub_flow_groups[0]  # 只查看，不弹出\n                self.super_flow_logger.info(f\"=== 开始执行步骤组（{len(current_parallel_group)}个步骤） ===\")\n                # 添加顺序执行逻辑\n                if current_parallel_group:  # 确保当前组还有步骤\n                    step = current_parallel_group.pop(0)  # 取出第一个步骤\n\n                    self.knowledge.add_message({\n                        'role': \"user\",\n                        'content': step.description\n                    })\n\n                    async for execute_event in self.execute_step(step=step):\n                        yield execute_event  # 传播 execute_step 内部过滤后的事件\n                        self.super_flow_logger.debug(f\"执行事件类型: {type(execute_event).__name__}\")\n\n                        if isinstance(execute_event, AgentEvent):\n                            event_type = type(execute_event).__name__\n                            self.super_flow_logger.debug(\"=\" * 50)\n                            self.super_flow_logger.debug(f\">>> 执行事件类型: {event_type} <<<\")\n                            self.super_flow_logger.debug(\"=\" * 50)\n\n                    self.knowledge.add_message({\n                        'role': \"assistant\",\n                        'content': step.result\n                    })\n\n                    self.knowledge.add_file(step.file)\n                    self.knowledge.add_web(step.web)\n\n                    # 每个步骤执行完后立即进入更新状态\n                    self.status = FlowStatus.UPDATING\n                    self.super_flow_logger.info(f\"步骤 {step.id} 执行完成，状态变更: EXECUTING -> UPDATING\")\n                \n                # 并发处理，如果当前组为空，移除它\n                if not current_parallel_group:\n                    self.parallel_sub_flow_groups.popleft()  # 安全地移除空组\n\n            elif self.status == FlowStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.super_flow_logger.info(f\"=== 开始更新计划 ===\")\n                async for event in self.planner_agent.update_plan(plan=self.plan, step=step):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.super_flow_logger.info(f\"=== 计划更新完成 ===\")\n                        self.super_flow_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.super_flow_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                        # 发送简洁的计划更新通知\n                        yield MessageEvent(message=f\"🔄 计划已更新，当前剩余{len([s for s in event.plan.steps if s.status == ExecutionStatus.PENDING])}个待执行步骤\")\n                    elif isinstance(event, MessageEvent):\n                        self.super_flow_logger.info(f\"计划更新输出: {event.message}\")\n                        # 不转发JSON格式的MessageEvent\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                        # 转发重要的状态变化事件\n                        yield event\n\n                    # 创建计划完成后，准备执行步骤\n                    if self.plan:\n                        self._build_parallel_execution_groups()\n\n                        # 检查是否有任何步骤可以执行,如果没有进入报告阶段\n                        if not self.parallel_sub_flow_groups:\n                            self.super_flow_logger.info(\"没有剩余的待执行步骤，进入报告阶段\")\n                            self.status = FlowStatus.REPORTING\n                            continue\n                        # 状态转换到执行阶段\n                        self.status = FlowStatus.EXECUTING\n                        self.super_flow_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == FlowStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.super_flow_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 发送简洁的完成通知\n                yield MessageEvent(message=\"所有步骤已完成，正在生成最终报告...\")\n\n                # 生成最终报告\n                async for event in self.report_agent.generate_report(plan=self.plan):\n                    yield event\n\n                self.status = FlowStatus.COMPLETED\n                self.super_flow_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n\n            elif self.status == FlowStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                self.super_flow_logger.info(f\"=== 计划执行完成 ===\")\n                self.super_flow_logger.info(f\"最终计划状态: {self.plan.status}\")\n                yield PlanCompletedEvent(plan=self.plan, issuperplan=True)\n                self.status = FlowStatus.IDLE\n                self.super_flow_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n\n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.super_flow_logger.info(f\"=== 消息处理完成 ===\")\n\n    def is_idle(self) -> bool:\n        return self.status == FlowStatus.IDLE\n\n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(\n                f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n\n    def add_report_to_knowledge(self, current_report):\n        self.knowledge.add_message({\n            'role': \"assistant\",\n            'message': current_report\n        })\n\n    def add_step_to_knowledge(self, current_step):\n        self.knowledge.add_message({\n            'role': \"user\",\n            'message': current_step\n        })",
      "methods": [
        "<module>.SuperFlow.__init__",
        "<module>.SuperFlow._determine_task_type",
        "<module>.SuperFlow.execute_step",
        "<module>.SuperFlow._build_parallel_execution_groups",
        "<module>.SuperFlow.run",
        "<module>.SuperFlow.is_idle",
        "<module>.SuperFlow._show_plan",
        "<module>.SuperFlow.add_report_to_knowledge",
        "<module>.SuperFlow.add_step_to_knowledge"
      ],
      "description": "Orchestrates the entire multi-phase workflow by coordinating planning, parallel/sub-flow execution, updates, and final reporting; interacts with PlannerAgent, ReportAgent, NotifyAgent, and sub-flows created via sub_flow_factory, while maintaining memories and execution history."
    },
    {
      "file": "/app/sample_workspace/flows/plan_act.py",
      "name": "AgentStatus",
      "qualname": "<module>.AgentStatus",
      "source": "class AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    PLANNING = \"planning\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    UPDATING = \"updating\"\n    REPORTING = \"reporting\"\n",
      "methods": [],
      "description": "Enum capturing the high-level lifecycle of the plan-act flow (IDLE, PLANNING, EXECUTING, COMPLETED, UPDATING, REPORTING) to coordinate state transitions."
    },
    {
      "file": "/app/sample_workspace/flows/plan_act.py",
      "name": "SubPlannerType",
      "qualname": "<module>.SubPlannerType",
      "source": "class SubPlannerType(Enum):\n    MESSAGE = \"message\"\n    SHELL = \"shell\"\n    SEARCH = \"search\"\n    FILE = \"file\"\n",
      "methods": [],
      "description": "Enum listing sub-planner categories (MESSAGE, SHELL, SEARCH, FILE) that can be used by the planning subsystem to categorize tasks."
    },
    {
      "file": "/app/sample_workspace/flows/plan_act.py",
      "name": "PlanActFlow",
      "qualname": "<module>.PlanActFlow",
      "source": "class PlanActFlow(BaseFlow):\n    # 定义flow的唯一标识符\n    flow_id = \"plan_act\"\n    description = \"计划-执行流程：先创建计划，然后逐步执行，支持动态更新计划\"\n    \n    def __init__(self, agent: Agent, llm: LLM, audio_llm: AudioLLM, image_llm: ImageLLM, video_llm: VideoLLM, reason_llm: ReasonLLM, sandbox: Sandbox, browser: Browser, \n                 search_engine: Optional[SearchEngine] = None, **kwargs):\n        super().__init__(agent, **kwargs)\n        self.status = AgentStatus.IDLE\n        self.plan = None\n        \n        # 设置专门的日志记录器\n        self.plan_act_logger = setup_plan_act_logger(\"plan_act\")\n        self.plan_act_logger.info(f\"=== PlanActFlow初始化 Agent ID: {agent.id} ===\")\n        \n        # 创建计划代理和执行代理\n        self.planner = PlannerAgent(\n            llm=llm,\n            memory=agent.planner_memory,\n        )\n        logger.debug(f\"Created planner agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Planner Agent完成\")\n        \n        self.executor = ExecutionAgent(\n            llm=llm,\n            audio_llm=audio_llm,\n            image_llm=image_llm,\n            video_llm=video_llm,\n            reason_llm=reason_llm,\n            memory=agent.execution_memory,\n            sandbox=sandbox,\n            browser=browser,\n            search_engine=search_engine,\n        )\n        logger.debug(f\"Created execution agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Execution Agent完成\")\n        \n        # 创建通知代理，与执行代理共用memory\n        self.notifier = NotifyAgent(\n            llm=llm,\n            memory=Memory(),  # 与execution agent共用memory\n        )\n        logger.debug(f\"Created notify agent for Agent {self.agent.id}\")\n        self.plan_act_logger.info(f\"创建Notify Agent完成\")\n\n    async def run(self, message: str) -> AsyncGenerator[AgentEvent, None]:\n        self.plan_act_logger.info(f\"=== 开始处理用户消息 ===\")\n        self.plan_act_logger.info(f\"用户输入: {message}\")\n        \n        if not self.is_idle():\n            # interrupt the current flow\n            self.status = AgentStatus.PLANNING\n            self.planner.roll_back()\n            self.executor.roll_back()\n            self.notifier.roll_back()  # 同时回滚notify agent\n            self.plan_act_logger.info(\"中断当前流程，重新开始规划\")\n\n        logger.info(f\"Agent {self.agent.id} started processing message: {message[:50]}...\")\n        step = None\n        while True:\n            if self.status == AgentStatus.IDLE:\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}\")\n                self.status = AgentStatus.PLANNING\n                self.plan_act_logger.info(f\"状态变更: IDLE -> PLANNING\")\n                \n                # 通知用户开始规划\n                async for event in self.notifier.notify_received_message(message):\n                    yield event\n                    \n            elif self.status == AgentStatus.PLANNING:\n                # 创建计划\n                logger.info(f\"Agent {self.agent.id} started creating plan\")\n                self.plan_act_logger.info(f\"=== 开始创建计划 ===\")\n                self.plan_act_logger.info(f\"Planner输入: {message}\")\n                \n                async for event in self.planner.create_plan(message):\n                    if isinstance(event, PlanCreatedEvent):\n                        self.plan = event.plan\n                        logger.info(f\"Agent {self.agent.id} created plan successfully with {len(event.plan.steps)} steps\")\n                        self.plan_act_logger.info(f\"=== 计划创建成功 ===\")\n                        self.plan_act_logger.info(f\"计划ID: {event.plan.id}\")\n                        self.plan_act_logger.info(f\"计划目标: {event.plan.goal}\")\n                        self.plan_act_logger.info(f\"计划标题: {event.plan.title}\")\n                        self.plan_act_logger.info(f\"计划步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}\")\n                        if event.plan.message:\n                            self.plan_act_logger.info(f\"计划说明: {event.plan.message}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Planner输出: {event.message}\")\n                    yield event\n                logger.info(f\"Agent {self.agent.id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: PLANNING -> EXECUTING\")\n                    \n            elif self.status == AgentStatus.EXECUTING:\n                # 执行计划\n                self.plan.status = ExecutionStatus.RUNNING\n                step = self.plan.get_next_step()\n                if not step:\n                    logger.info(f\"Agent {self.agent.id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.REPORTING}\")\n                    self.status = AgentStatus.REPORTING\n                    self.plan_act_logger.info(f\"所有步骤执行完成，状态变更: EXECUTING -> REPORTING\")\n                    continue\n                    \n                # 执行步骤\n                logger.info(f\"Agent {self.agent.id} started executing step {step.id}: {step.description[:50]}...\")\n                self.plan_act_logger.info(f\"=== 开始执行步骤 ===\")\n                self.plan_act_logger.info(f\"步骤ID: {step.id}\")\n                self.plan_act_logger.info(f\"步骤描述: {step.description}\")\n                self.plan_act_logger.info(f\"Executor输入: 目标={self.plan.goal}, 步骤={step.description}\")\n                \n                async for event in self.executor.execute_step(self.plan, step, message):\n                    if isinstance(event, ToolCallingEvent):\n                        self.plan_act_logger.info(f\"工具调用: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具参数: {event.function_args}\")\n                    elif isinstance(event, ToolCalledEvent):\n                        self.plan_act_logger.info(f\"工具结果: {event.tool_name}\")\n                        self.plan_act_logger.info(f\"工具函数: {event.function_name}\")\n                        self.plan_act_logger.info(f\"工具输出: {event.function_result}\")\n                        if hasattr(event, 'error') and event.error:\n                            self.plan_act_logger.error(f\"工具错误: {event.error}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"Executor输出: {event.message}\")\n                    yield event\n                        \n                logger.info(f\"Agent {self.agent.id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}\")\n                self.plan_act_logger.info(f\"步骤执行完成: {step.id}\")\n                self.plan_act_logger.info(f\"步骤状态: {step.status}\")\n                if step.result:\n                    self.plan_act_logger.info(f\"步骤结果: {step.result}\")\n                if step.error:\n                    self.plan_act_logger.error(f\"步骤错误: {step.error}\")\n                self.status = AgentStatus.UPDATING\n                self.plan_act_logger.info(f\"状态变更: EXECUTING -> UPDATING\")\n                \n            elif self.status == AgentStatus.UPDATING:\n                if self.plan.status == ExecutionStatus.PAUSED:\n                    break\n                    \n                # 执行Agent总结所作所为 / 压缩记忆上下文 / 获取浓缩的记忆，给到更新计划Agent\n                self.plan_act_logger.info(f\"=== 开始总结步骤 ===\")\n                previous_steps = \"\"\n                async for event in self.executor.summarize_steps():\n                    yield event\n                    if isinstance(event, MessageEvent):\n                        logger.info(f\"Agent {self.agent.id} summarized steps, message: {event.message}\")\n                        previous_steps = event.message\n                        self.plan_act_logger.info(f\"步骤总结完成: {event.message}\")\n                        \n                # 更新计划\n                logger.info(f\"Agent {self.agent.id} started updating plan\")\n                self.plan_act_logger.info(f\"=== 开始更新计划 ===\")\n                self.plan_act_logger.info(f\"计划更新输入 - 当前计划: {self.plan.model_dump_json(include={'steps'})}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 目标: {self.plan.goal}\")\n                self.plan_act_logger.info(f\"计划更新输入 - 已完成步骤总结: {previous_steps}\")\n                \n                async for event in self.planner.update_plan(self.plan, previous_steps):\n                    if isinstance(event, PlanUpdatedEvent):\n                        self._show_plan(event.plan)\n                        self.plan_act_logger.info(f\"=== 计划更新完成 ===\")\n                        self.plan_act_logger.info(f\"更新后步骤数量: {len(event.plan.steps)}\")\n                        for i, step in enumerate(event.plan.steps, 1):\n                            status_info = f\" (状态: {step.status})\" if step.status != ExecutionStatus.PENDING else \"\"\n                            self.plan_act_logger.info(f\"步骤{i}: [{step.id}] {step.description}{status_info}\")\n                    elif isinstance(event, MessageEvent):\n                        self.plan_act_logger.info(f\"计划更新输出: {event.message}\")\n                    elif isinstance(event, PauseEvent):\n                        self.plan.status = ExecutionStatus.COMPLETED\n                        self.plan_act_logger.info(f\"状态变更: UPDATING -> COMPLETED\")\n                    yield event\n\n                logger.info(f\"Agent {self.agent.id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}\")\n                self.status = AgentStatus.EXECUTING\n                self.plan_act_logger.info(f\"状态变更: UPDATING -> EXECUTING\")\n\n            elif self.status == AgentStatus.REPORTING:\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 正在准备最终报告 ===\")\n                \n                # 通知用户计划全部完成\n                async for notify_event in self.notifier.notify_plan_progress(self.plan, \"所有步骤已完成，正在准备最终报告\"):\n                    yield notify_event\n                    \n                async for event in self.executor.report_result(message):\n                    yield event\n                    \n                self.status = AgentStatus.COMPLETED\n                self.plan_act_logger.info(f\"状态变更: REPORTING -> COMPLETED\")\n                \n            elif self.status == AgentStatus.COMPLETED:\n                self.plan.status = ExecutionStatus.COMPLETED\n                logger.info(f\"Agent {self.agent.id} plan has been completed\")\n                self.plan_act_logger.info(f\"=== 计划执行完成 ===\")\n                self.plan_act_logger.info(f\"最终计划状态: {self.plan.status}\")\n                    \n                yield PlanCompletedEvent(plan=self.plan) \n                self.status = AgentStatus.IDLE\n                self.plan_act_logger.info(f\"状态变更: COMPLETED -> IDLE\")\n                break\n        yield DoneEvent()\n        \n        logger.info(f\"Agent {self.agent.id} message processing completed\")\n        self.plan_act_logger.info(f\"=== 消息处理完成 ===\")\n    \n    def is_idle(self) -> bool:\n        return self.status == AgentStatus.IDLE\n    \n    def _show_plan(self, plan: Plan):\n        logger.info(\"-\" * 30)\n        logger.info(f\"Plan ID: {plan.id}\")\n        logger.info(f\"Plan Goal: {plan.goal}\")\n        for step in plan.steps:\n            logger.info(f\"[{step.id}] {step.description}, Status: {step.status}, Result: {step.result}, Error: {step.error}\")\n        logger.info(\"-\" * 30)\n",
      "methods": [
        "<module>.PlanActFlow.__init__",
        "<module>.PlanActFlow.run",
        "<module>.PlanActFlow.is_idle",
        "<module>.PlanActFlow._show_plan"
      ],
      "description": "Orchestrates the end-to-end process from user message to final plan execution, coordinating planning, execution, and notification agents, managing state transitions, and emitting domain events throughout the lifecycle. It exposes __init__, run, is_idle, and _show_plan as its main interfaces."
    }
  ]
}