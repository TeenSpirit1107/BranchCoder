{"docstore/metadata": {"file::0": {"doc_hash": "7f89bb6fb286b532c806007fd34d57a638c2726fec9002a0bcff575438199b90"}, "file::1": {"doc_hash": "dce6b1caeeee024565afec93c56316cdeda24b00a456b67c141b180f54242c69"}, "file::2": {"doc_hash": "86ee7f4221ee9b3b77170060723887fdc7b364517d5404fb6d8ea01980939161"}, "file::3": {"doc_hash": "421c0b6fef4f4741d60910daf8cd82e207b182f66af44f6d22854655c27b5d17"}, "file::4": {"doc_hash": "f8a65cb37406481331e62a2e5cef65836ec857aef38ba20d67c1949386c29d8f"}, "file::5": {"doc_hash": "4414ede900d3342decd30236d61446cf1429075db948661b607e43ad5ffe492c"}, "file::6": {"doc_hash": "5b0409957763543b87fcdb3706ff75a07bdc55378c3dc2158c9882de0de231f1"}, "file::7": {"doc_hash": "b2785b1462e69a09ec12041af1fae449e67f2ffe64c7484fa9c8f60ad3036bbb"}, "file::8": {"doc_hash": "ad698e8467f62050731e61b6821d2083e6aa9dc11f4b6b321a0168828653cca0"}, "752e989c-451d-47b5-a4eb-cd47ad9f0d79": {"doc_hash": "1af54d4bc9513c59426a704850694dae6cd60b64e9d5d3fa422cf9b22af66fa7", "ref_doc_id": "file::0"}, "c347af7e-ef76-4990-a24f-d84983ba72a9": {"doc_hash": "71f88eb63f7e1d4131ef71f3f550e615ec73c8ce4cf764ea7bc73c4493d0cbc3", "ref_doc_id": "file::1"}, "b86d8e40-f2cd-4ee8-a10a-8109afacc74e": {"doc_hash": "a8643b4921210bd00979dbc8f12cc427cb81c05d8d2cb786700fb9b265b11190", "ref_doc_id": "file::2"}, "949ade05-8a78-4915-be06-8e3b641ecc72": {"doc_hash": "3e827ab52e2a177e6bc5cd5f116cf5ff6a604611455aea01398191393cb58858", "ref_doc_id": "file::3"}, "354a96bd-999c-4751-8da6-c38d0500bb2a": {"doc_hash": "06d6736908bed761564910d44afbadb1ff9977a740a4d55d0a530f294af67dc1", "ref_doc_id": "file::4"}, "12687433-78eb-4683-96c5-99fd2dffa20d": {"doc_hash": "f2653612dfabfb133ca98d1d9bbd102cada0a51363c74aa457bc872fac71611d", "ref_doc_id": "file::5"}, "e0725b08-f17b-4b17-921e-8e383abd2c5e": {"doc_hash": "8a1b06fec68be2b290f39b960b24c48fca3020f070c63169c2b0f1b2b387c108", "ref_doc_id": "file::6"}, "2b0ca9dc-9894-4f3c-ae03-f744b195c0ed": {"doc_hash": "73de5fdb5bfb5905b5eecbf7fa9eef690eae5c95b3b0f51181f81c80951febfa", "ref_doc_id": "file::7"}, "aec6d613-92de-4c1a-9619-01df6ced90a5": {"doc_hash": "4afc57a76ddbdbeff00454f7e72961316dc327d8f18fc79f2fb2f08e15a4b803", "ref_doc_id": "file::8"}}, "docstore/ref_doc_info": {"file::0": {"node_ids": ["752e989c-451d-47b5-a4eb-cd47ad9f0d79"], "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}}, "file::1": {"node_ids": ["c347af7e-ef76-4990-a24f-d84983ba72a9"], "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}}, "file::2": {"node_ids": ["b86d8e40-f2cd-4ee8-a10a-8109afacc74e"], "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}}, "file::3": {"node_ids": ["949ade05-8a78-4915-be06-8e3b641ecc72"], "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}}, "file::4": {"node_ids": ["354a96bd-999c-4751-8da6-c38d0500bb2a"], "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}}, "file::5": {"node_ids": ["12687433-78eb-4683-96c5-99fd2dffa20d"], "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}}, "file::6": {"node_ids": ["e0725b08-f17b-4b17-921e-8e383abd2c5e"], "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}}, "file::7": {"node_ids": ["2b0ca9dc-9894-4f3c-ae03-f744b195c0ed"], "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}}, "file::8": {"node_ids": ["aec6d613-92de-4c1a-9619-01df6ced90a5"], "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}}}, "docstore/data": {"752e989c-451d-47b5-a4eb-cd47ad9f0d79": {"__data__": {"id_": "752e989c-451d-47b5-a4eb-cd47ad9f0d79", "embedding": null, "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::0", "node_type": "4", "metadata": {"type": "file", "idx": 0, "file": "flows/base.py"}, "hash": "7f89bb6fb286b532c806007fd34d57a638c2726fec9002a0bcff575438199b90", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "BaseFlow and BaseSubFlow abstractions for flow execution and sub-planning The file defines two abstract base classes that standardize how flows and sub-flows are implemented in the system. It enforces that every concrete flow provides a unique flow_id and common lifecycle methods (run and is_idle), and exposes helper methods to query flow identifiers and descriptions. BaseFlow manages an Agent dependency and validates configuration at initialization, while BaseSubFlow encapsulates various external interfaces (LLMs, sandbox, browser, search) and memory of a planning step to be used by concrete sub-flows. Together, they establish the collaboration surface between high-level flows, sub-flows, and the external tools they leverage.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 736, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c347af7e-ef76-4990-a24f-d84983ba72a9": {"__data__": {"id_": "c347af7e-ef76-4990-a24f-d84983ba72a9", "embedding": null, "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::1", "node_type": "4", "metadata": {"type": "file", "idx": 1, "file": "flows/sub_planner_flow.py"}, "hash": "dce6b1caeeee024565afec93c56316cdeda24b00a456b67c141b180f54242c69", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The SubPlannerFlow module defines a specialized flow that coordinates the creation and execution of sub-plans within a larger planning system. It initializes a dedicated logger, maintains an internal status tracker using AgentStatus, and wires together a SubPlannerAgent and an ExecutionAgent with various LLMs and external services (Sandbox, Browser, optional SearchEngine, and optional multimodal LLMs). The flow interacts with a Memory store and a PromptManager to manage dynamic prompts and state, updating system prompts as the sub-plan progresses. Its run method orchestrates the end-to-end lifecycle: from planning to executing steps, handling updates, summarization, and reporting, while emitting a stream of AgentEvent-derived messages to the caller. It collaborates with a parent planner by consuming parent plan/step/memory and a task type, performing planning, execution, and sub-plan updates through its agent components.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b86d8e40-f2cd-4ee8-a10a-8109afacc74e": {"__data__": {"id_": "b86d8e40-f2cd-4ee8-a10a-8109afacc74e", "embedding": null, "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::2", "node_type": "4", "metadata": {"type": "file", "idx": 2, "file": "flows/default_flow.py"}, "hash": "86ee7f4221ee9b3b77170060723887fdc7b364517d5404fb6d8ea01980939161", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "File-level summary This module defines a default sub-flow that orchestrates sub-planning and execution within a larger workflow. It introduces an AgentStatus enum to track the lifecycle states of the flow (idle, planning, executing, updating, reporting, completed). The DefaultFlow class extends a base sub-flow and coordinates two internal agents: a SubPlannerAgent for generating a sub-plan and an ExecutionAgent for carrying out the plan\u2019s steps. It wires together LLMs, sandbox, browser, optional search, and various multimodal helpers, along with memory and prompt management to adapt prompts dynamically based on context. Extensive logging is used through a specialized sub-planner logger to trace initialization, plan creation, step execution, plan updates, and final reporting. The run method implements an end-to-end lifecycle: initialize agents, create a sub-plan, execute steps, summarize and update the sub-plan, and emit final events such as a plan completion or a report, enabling integration with the parent planning flow.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1037, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "949ade05-8a78-4915-be06-8e3b641ecc72": {"__data__": {"id_": "949ade05-8a78-4915-be06-8e3b641ecc72", "embedding": null, "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::3", "node_type": "4", "metadata": {"type": "file", "idx": 3, "file": "flows/search_flow.py"}, "hash": "421c0b6fef4f4741d60910daf8cd82e207b182f66af44f6d22854655c27b5d17", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "File-level summary - This file defines a SearchFlow class that orchestrates a multi-step, gap-based reflection search workflow. It leverages a large language model (LLM) and an execution engine to iteratively generate, search, evaluate, reflect on, and refine gaps until a final answer can be produced. It maintains an in-memory knowledge base of solved gaps and their summaries, and supports serial execution (as opposed to parallel) for gap processing. The flow integrates with memory, plan/step models, and executor events, and heavily relies on structured prompts to guide evaluation, gap generation, and final answer synthesis. Several helper methods format search results, manage gap queues, and generate final outputs.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 725, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "354a96bd-999c-4751-8da6-c38d0500bb2a": {"__data__": {"id_": "354a96bd-999c-4751-8da6-c38d0500bb2a", "embedding": null, "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::4", "node_type": "4", "metadata": {"type": "file", "idx": 4, "file": "flows/code_flow.py"}, "hash": "f8a65cb37406481331e62a2e5cef65836ec857aef38ba20d67c1949386c29d8f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "CodeFlow orchestrates a sub-plan lifecycle: it initializes specialized agents (a sub-planner and an execution agent), creates a sub-plan from a parent plan/step, executes the sub-plan step-by-step, dynamically updates the sub-plan based on execution outcomes, and finally reports completion. It relies on a rich set of domain models (events, plans, steps) and external services (LLMs, sandbox, browser, search) plus a memory and prompt-management subsystem to maintain and adjust the planning and execution context. The file defines an AgentStatus enum to track the sub-flow's lifecycle and a CodeFlow class that coordinates planning, execution, updating, and reporting, emitting various AgentEvents to its caller. It integrates detailed logging for observability and uses asynchronous iteration to stream events from sub-components. The CodeFlow interacts closely with SubPlannerAgent and ExecutionAgent, updating prompts and memory as the flow progresses and handling errors with robust logging and fallbacks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1011, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "12687433-78eb-4683-96c5-99fd2dffa20d": {"__data__": {"id_": "12687433-78eb-4683-96c5-99fd2dffa20d", "embedding": null, "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::5", "node_type": "4", "metadata": {"type": "file", "idx": 5, "file": "flows/factory.py"}, "hash": "4414ede900d3342decd30236d61446cf1429075db948661b607e43ad5ffe492c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "FlowFactory and SubFlowFactory implement a flexible factory system for creating both high-level flows and sub-flows. The file registers default flow types, validates and instantiates flow classes with rich dependencies (agent, LLMs, sandbox, browser, search engine, etc.), and exposes APIs to query available flows and check existence. It defines a global FlowFactory instance and a SubFlowFactory with a separate SubPlannerType enum to map high-level task types to specific sub-flows. The code relies on multiple flow implementations (PlanActFlow, SimpleChatFlow, SuperFlow, DefaultFlow, SearchFlow, CodeFlow) and integrates with domain models (Agent) and external services (LLM, Sandbox, Browser, SearchEngine). Logging is extensively used to trace registration, creation, and error conditions, including a dedicated logger for sub-flow operations.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 850, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e0725b08-f17b-4b17-921e-8e383abd2c5e": {"__data__": {"id_": "e0725b08-f17b-4b17-921e-8e383abd2c5e", "embedding": null, "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::6", "node_type": "4", "metadata": {"type": "file", "idx": 6, "file": "flows/simple_chat.py"}, "hash": "5b0409957763543b87fcdb3706ff75a07bdc55378c3dc2158c9882de0de231f1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This file defines SimpleChatFlow, a concrete implementation of a chat flow that directly talks to a language model (LLM) without planning or executing extra steps. It wires together various external services and models, including multiple specialized LLM interfaces (LLM, AudioLLM, ImageLLM, VideoLLM, ReasonLLM), a Sandbox, a Browser, and an optional SearchEngine, and it interacts with domain models such as Agent and domain events like AgentEvent, MessageEvent, and DoneEvent. The flow maintains an internal idle state (_is_idle) to indicate availability and uses asynchronous generation to emit events as the conversation progresses. The run method constructs a simple prompt, queries the LLM, and yields a MessageEvent with the LLM response, handling errors by emitting an error message and finally yielding a DoneEvent. Logging is used throughout to trace creation, start, success/failure, and completion of interactions with the agent.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 942, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2b0ca9dc-9894-4f3c-ae03-f744b195c0ed": {"__data__": {"id_": "2b0ca9dc-9894-4f3c-ae03-f744b195c0ed", "embedding": null, "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::7", "node_type": "4", "metadata": {"type": "file", "idx": 7, "file": "flows/super_flow.py"}, "hash": "b2785b1462e69a09ec12041af1fae449e67f2ffe64c7484fa9c8f60ad3036bbb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "File-level summary The file implements a high-level orchestration flow named SuperFlow that coordinates multiple sub-flows to tackle complex tasks. It defines a FlowStatus enum to represent the lifecycle states (idle, planning, executing, updating, reporting, completed) and a SuperFlow class that manages planning, execution, updating, and final reporting phases. It collaborates with various agents (PlannerAgent, ReportAgent, NotifyAgent) and external tools (LLMs, Sandbox, Browser, SearchEngine) and uses a sub_flow_factory to spawn specialized sub-flows based on the task type. It maintains separate memories for planning and knowledge, and tracks sub-flow execution history and active sub-flows. The run loop processes user messages, builds execution plans, executes steps (potentially in parallel groups), updates plans based on results, and emits events such as PlanCreatedEvent, StepStartedEvent, StepCompletedEvent, StepFailedEvent, and PlanUpdatedEvent to inform collaborators.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 988, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "aec6d613-92de-4c1a-9619-01df6ced90a5": {"__data__": {"id_": "aec6d613-92de-4c1a-9619-01df6ced90a5", "embedding": null, "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "file::8", "node_type": "4", "metadata": {"type": "file", "idx": 8, "file": "flows/plan_act.py"}, "hash": "ad698e8467f62050731e61b6821d2083e6aa9dc11f4b6b321a0168828653cca0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "PlanActFlow orchestrates a plan-then-act loop by coordinating planner, executor, and notifier sub-agents to transform user input into a concrete plan and iteratively execute and update it. It defines a small FSM of statuses (idle, planning, executing, updating, reporting, completed) to drive the flow, and relies on a variety of domain events (PlanCreatedEvent, PlanUpdatedEvent, ToolCallingEvent, etc.) to communicate progress. The module imports extensive domain models, memory, and external services (LLMs, Sandbox, Browser, SearchEngine) and uses a specialized plan-act logger alongside the standard logger for structured logging. It constructs PlannerAgent, ExecutionAgent, and NotifyAgent instances bound to the provided agent memories and external resources, enabling end-to-end orchestration from plan creation to final reporting. It also provides a helper for inspecting plans and a simple idle check to drive restarts, and it yields events to consumers as the flow progresses.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 987, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}}